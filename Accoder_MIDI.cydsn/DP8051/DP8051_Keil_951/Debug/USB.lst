C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\USB.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\USB.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\DP80
                    -51\DP8051_Keil_951\Debug/USB.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\USB.obj)

line level    source

   1          /***************************************************************************//**
   2          * \file USB.c
   3          * \version 3.10
   4          *
   5          * \brief
   6          *  This file contains the global USBFS API functions.
   7          *
   8          * Note:
   9          *  Many of the functions use an endpoint number. SRAM arrays are sized with 9
  10          *  elements, so they are indexed directly by epNumber.  The SIE and ARB
  11          *  registers are indexed by variations of epNumber - 1.
  12          *
  13          ********************************************************************************
  14          * \copyright
  15          * Copyright 2008-2016, Cypress Semiconductor Corporation.  All rights reserved.
  16          * You may use this file only in accordance with the license, terms, conditions,
  17          * disclaimers, and limitations in the end user license agreement accompanying
  18          * the software package with which this file was provided.
  19          *******************************************************************************/
  20          
  21          #include "USB_pvt.h"
  22          #include "USB_cydmac.h"
  23          #include "USB_hid.h"
  24          #include "USB_Dp.h"
  25          
  26          
  27          /***************************************
  28          * Global data allocation
  29          ***************************************/
  30          
  31          /** Indicates whether the USBFS has been initialized. The variable is
  32          * initialized to 0 after device reset and set to 1 the first time USBFS_Start()
  33          * is called. This allows the Component to restart without reinitialization after
  34          * the first call to the USBFS_Start() routine.
  35          * If re-initialization of the Component is required, the variable should be set
  36          * to 0 before the USBFS_Start() routine is called. Alternatively, the USBFS can
  37          * be reinitialized by calling both USBFS_Init() and USBFS_InitComponent()
  38          * functions.
  39          */
  40          uint8 USB_initVar = 0u;
  41          
  42          #if (USB_EP_MANAGEMENT_DMA)
                  #if (CY_PSOC4)
                      static void USB_InitEpDma(void);
              
                      /* DMA chanels assigend for endpoints. */
                      const uint8 USB_DmaChan[USB_MAX_EP] =
                      {
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 2   

                          0u,
                          0u,
                          0u,
                          0u,
                      };        
                  #else
                      /* DMA chanels assigend for endpoints. */
                      uint8 USB_DmaChan[USB_MAX_EP];
                      
                      /* DMA TDs require for PSoC 3/5LP operation. */
                      uint8 USB_DmaTd[USB_MAX_EP];
                  #endif /* (CY_PSOC4) */
              #endif /* (USB_EP_MANAGEMENT_DMA) */
  67          
  68          #if (USB_EP_MANAGEMENT_DMA_AUTO)
              #if (CY_PSOC4)
                  /* Number of DMA bursts. */
                  uint8  USB_DmaEpBurstCnt   [USB_MAX_EP];
                  
                  /* Number of bytes to transfer in last DMA burst. */
                  uint8  USB_DmaEpLastBurstEl[USB_MAX_EP];
              
                  /* Storage for arrays above. */
                  uint8  USB_DmaEpBurstCntBackup  [USB_MAX_EP];
                  uint32 USB_DmaEpBufferAddrBackup[USB_MAX_EP];
                   
                  /* DMA trigger mux output for usb.dma_req[0-7]. */
                  const uint8 USB_DmaReqOut[USB_MAX_EP] =
                  {
                      0u,
                      USB_ep1_dma__TR_OUTPUT,
                      USB_ep2_dma__TR_OUTPUT,
                      0u,
                      0u,
                      0u,
                      0u,
                      0u,
                      0u,
                  };
              
                  /* DMA trigger mux output for usb.dma_burstend[0-7]. */
                  const uint8 USB_DmaBurstEndOut[USB_MAX_EP] =
                  {
                      0u,
                      USB_BURSTEND_0_TR_OUTPUT,
                      USB_BURSTEND_1_TR_OUTPUT,
                      USB_BURSTEND_2_TR_OUTPUT,
                      USB_BURSTEND_3_TR_OUTPUT,
                      USB_BURSTEND_4_TR_OUTPUT,
                      USB_BURSTEND_5_TR_OUTPUT,
                      USB_BURSTEND_6_TR_OUTPUT,
                      USB_BURSTEND_7_TR_OUTPUT
                  };
                  
              #else
                  #if (USB_EP_DMA_AUTO_OPT == 0u)
                      static uint8 clearInDataRdyStatus = USB_ARB_EPX_CFG_DEFAULT;
                      uint8 USB_DmaNextTd[USB_MAX_EP];
                      const uint8 USB_epX_TD_TERMOUT_EN[USB_MAX_EP] =
                      {
                          0u,
                          0u,
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 3   

                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                          0u,
                      };
              
                      volatile uint16 USB_inLength[USB_MAX_EP];
                      const uint8 *USB_inDataPointer[USB_MAX_EP];
                      volatile uint8 USB_inBufFull[USB_MAX_EP];
                  #endif /* (USB_EP_DMA_AUTO_OPT == 0u) */
              #endif /* (CY_PSOC4) */
              #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
 131          
 132          
 133          /*******************************************************************************
 134          * Function Name: USB_Start
 135          ****************************************************************************//**
 136          *
 137          *   This function performs all required initialization for the USBFS component.
 138          *   After this function call, the USB device initiates communication with the
 139          *   host by pull-up D+ line. This is the preferred method to begin component
 140          *   operation.
 141          *
 142          *   Note that global interrupts have to be enabled because interrupts are
 143          *   required for USBFS component operation.
 144          *
 145          *   PSoC 4200L devices: when USBFS component configured to DMA with Automatic
 146          *   Buffer Management, the DMA interrupt priority is changed to the highest
 147          *   (priority 0) inside this function.
 148          *
 149          *   PSoC 3/PSoC 5LP devices: when USBFS component configured to DMA with
 150          *   Automatic Buffer Management, the Arbiter interrupt priority is changed to
 151          *   the highest (priority 0) inside this function.
 152          *
 153          *  \param device
 154          *          Contains the device number of the desired device descriptor.
 155          *          The device number can be found in the Device Descriptor Tab of
 156          *          "Configure" dialog, under the settings of desired Device Descriptor,
 157          *          in the "Device Number" field.
 158          *  \param mode:
 159          *   The operating voltage. This determines whether the voltage regulator
 160          *   is enabled for 5V operation or if pass through mode is used for 3.3V
 161          *   operation. Symbolic names and their associated values are given in the
 162          *   following list.
 163          *
 164          *       *USB_3V_OPERATION* - Disable voltage regulator and pass-
 165          *                                      through Vcc for pull-up
 166          *
 167          *       *USB_5V_OPERATION* - Enable voltage regulator and use
 168          *                                      regulator for pull-up
 169          *
 170          *       *USB_DWR_POWER_OPERATION* - Enable or disable the voltage
 171          *                                      regulator depending on the power supply
 172          *                                      voltage configuration in the DWR tab.
 173          *                                      For PSoC 3/5LP devices, the VDDD supply
 174          *                                      voltage is considered and for PSoC 4A-L,
 175          *                                      the VBUS supply voltage is considered.*
 176          * \globalvars
 177          *  \ref USB_initVar
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 4   

 178          *
 179          * \sideeffect
 180          *   This function will reset all communication states to default.
 181          *
 182          * \reentrant
 183          *  No.
 184          *
 185          *******************************************************************************/
 186          void USB_Start(uint8 device, uint8 mode) 
 187          {
 188   1          if (0u == USB_initVar)
 189   1          {
 190   2              USB_Init();
 191   2              USB_initVar = 1u;
 192   2          }
 193   1      
 194   1          USB_InitComponent(device, mode);
 195   1      }
 196          
 197          
 198          /*******************************************************************************
 199          * Function Name: USB_Init
 200          ****************************************************************************//**
 201          *
 202          * This function initializes or restores the component according to the
 203          * customizer Configure dialog settings. It is not necessary to call
 204          * USB_Init() because the USB_Start() routine calls
 205          * this function and is the preferred method to begin component operation.
 206          *
 207          * \reentrant
 208          *  No.
 209          *
 210          *******************************************************************************/
 211          void USB_Init(void) 
 212          {
 213   1      #if (CY_PSOC4)
                  /* Enable clock to USB IP. */
                  USB_USB_CLK_EN_REG = USB_USB_CLK_CSR_CLK_EN;
              
                  /* The internal regulator (CR1.REG_ENABLE) is enabled in
                  * USB_InitComponent() if it is required.
                  */
              
                  /* Enable USBIO control on drive mode of D+ and D- pins. */
                  USB_USBIO_CR1_REG &= ~ (uint32) USB_USBIO_CR1_IOMODE;
              
                  /* Set number of LF CLK to detect UBS bus reset. */
                  USB_BUS_RST_CNT_REG = USB_DEFUALT_BUS_RST_CNT;
              
                  /* Select VBUS detection source and clear PHY isolate. The application level
                  * must ensure that VBUS is valid. There is no need to wait 2us before VBUS is valid.
                  */
                  USB_POWER_CTRL_REG = USB_DEFAULT_POWER_CTRL_VBUS;
              
                  /* Enable PHY detector and single-ended and differential receivers. */
                  USB_POWER_CTRL_REG |= USB_DEFAULT_POWER_CTRL_PHY;
              
                  /* Suspend clear sequence. */
                  USB_POWER_CTRL_REG &= (uint32) ~USB_POWER_CTRL_SUSPEND;
                  CyDelayUs(USB_WAIT_SUSPEND_DEL_DISABLE);
                  USB_POWER_CTRL_REG &= (uint32) ~USB_POWER_CTRL_SUSPEND_DEL;
              
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 5   

                  /* Sets IMO lock options and clear all other bits. */
                  USB_CR1_REG = USB_DEFUALT_CR1;
              
                  /* Configure level (hi, lo, med) for each interrupt source. */
                  USB_INTR_LVL_SEL_REG = USB_DEFAULT_INTR_LVL_SEL;
              
                  /* Configure interrupt sources from: SOF, Bus Reset and EP0. */
                  USB_INTR_SIE_MASK_REG = USB_DEFAULT_INTR_SIE_MASK;
              
              #else
 250   1          uint8 enableInterrupts = CyEnterCriticalSection();
 251   1      
 252   1      #if (USB_EP_MANAGEMENT_DMA)
                  uint16 i;
              #endif /* (USB_EP_MANAGEMENT_DMA) */
 255   1      
 256   1          /* Enable USB block. */
 257   1          USB_PM_ACT_CFG_REG |= USB_PM_ACT_EN_FSUSB;
 258   1          /* Enable USB block for Standby Power Mode. */
 259   1          USB_PM_STBY_CFG_REG |= USB_PM_STBY_EN_FSUSB;
 260   1      
 261   1          /* Enable core clock. */
 262   1          USB_USB_CLK_EN_REG = USB_USB_CLK_ENABLE;
 263   1      
 264   1          USB_CR1_REG = USB_CR1_ENABLE_LOCK;
 265   1      
 266   1          /* ENABLING USBIO PADS IN USB MODE FROM I/O MODE. */
 267   1          /* Ensure USB transmit enable is low (USB_USBIO_CR0.ten). - Manual Transmission - Disabled. */
 268   1          USB_USBIO_CR0_REG &= (uint8) ~USB_USBIO_CR0_TEN;
 269   1          CyDelayUs(USB_WAIT_REG_STABILITY_50NS);  /* ~50ns delay. */
 270   1          /* Disable USBIO by asserting PM.USB_CR0.fsusbio_pd_n(Inverted.
 271   1          *  high. These bits will be set low by the power manager out-of-reset.
 272   1          *  Also confirm USBIO pull-up is disabled.
 273   1          */
 274   1          USB_PM_USB_CR0_REG &= (uint8) ~(USB_PM_USB_CR0_PD_N |
 275   1                                                       USB_PM_USB_CR0_PD_PULLUP_N);
 276   1      
 277   1          /* Select IOMODE to USB mode. */
 278   1          USB_USBIO_CR1_REG &= (uint8) ~USB_USBIO_CR1_IOMODE;
 279   1      
 280   1          /* Enable USBIO reference by setting PM.USB_CR0.fsusbio_ref_en. */
 281   1          USB_PM_USB_CR0_REG |= USB_PM_USB_CR0_REF_EN;
 282   1          /* Reference is available for 1us after regulator is enabled. */
 283   1          CyDelayUs(USB_WAIT_REG_STABILITY_1US);
 284   1          /* OR 40us after power is restored. */
 285   1          CyDelayUs(USB_WAIT_VREF_RESTORE);
 286   1          /* Ensure single-ended disable bits are low (PRT15.INP_DIS[7:6])(input receiver enabled). */
 287   1          USB_DM_INP_DIS_REG &= (uint8) ~USB_DM_MASK;
 288   1          USB_DP_INP_DIS_REG &= (uint8) ~USB_DP_MASK;
 289   1      
 290   1          /* Enable USBIO. */
 291   1          USB_PM_USB_CR0_REG |= USB_PM_USB_CR0_PD_N;
 292   1          CyDelayUs(USB_WAIT_PD_PULLUP_N_ENABLE);
 293   1          /* Set USBIO pull-up enable. */
 294   1          USB_PM_USB_CR0_REG |= USB_PM_USB_CR0_PD_PULLUP_N;
 295   1      
 296   1          /* Reset Arbiter Write Address register for endpoint 1. */
 297   1          CY_SET_REG8(USB_ARB_RW1_WA_PTR,     0u);
 298   1          CY_SET_REG8(USB_ARB_RW1_WA_MSB_PTR, 0u);
 299   1      
 300   1      #if (USB_EP_MANAGEMENT_DMA)
                  /* Initialize transfer descriptor. This will be used to detect DMA state - initialized or not. */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 6   

                  for (i = 0u; i < USB_MAX_EP; ++i)
                  {
                      USB_DmaTd[i] = DMA_INVALID_TD;
              
                  #if (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u))
                      USB_DmaNextTd[i] = DMA_INVALID_TD;
                  #endif /* (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u)) */
                  }
              #endif /* (USB_EP_MANAGEMENT_DMA) */
 311   1      
 312   1          CyExitCriticalSection(enableInterrupts);
 313   1      #endif /* (CY_PSOC4) */
 314   1      
 315   1          /* Configure interrupts from USB block. */
 316   1      #if (CY_PSOC4)
                  /* Configure hi_int: set handler and priority. */
                  CyIntSetPriority     (USB_INTR_HI_VECT_NUM,  USB_INTR_HI_PRIORITY);
                  (void) CyIntSetVector(USB_INTR_HI_VECT_NUM, &USB_INTR_HI_ISR);
              
                  /* Configure lo_int: set handler and priority. */
                  CyIntSetPriority     (USB_INTR_LO_VECT_NUM,  USB_INTR_LO_PRIORITY);
                  (void) CyIntSetVector(USB_INTR_LO_VECT_NUM, &USB_INTR_LO_ISR);
              
                  /* Configure med_int: set handler and priority (routed through DSI). */
                  CyIntSetPriority     (USB_INTR_MED_VECT_NUM,  USB_INTR_MED_PRIORITY);
                  (void) CyIntSetVector(USB_INTR_MED_VECT_NUM, &USB_INTR_MED_ISR);
              
              #else
 330   1          /* Set bus reset interrupt. */
 331   1          CyIntSetPriority(USB_BUS_RESET_VECT_NUM, USB_BUS_RESET_PRIOR);
 332   1          (void) CyIntSetVector(USB_BUS_RESET_VECT_NUM,   &USB_BUS_RESET_ISR);
 333   1      
 334   1          /* Set Control Endpoint Interrupt. */
 335   1          CyIntSetPriority(USB_EP_0_VECT_NUM, USB_EP_0_PRIOR);
 336   1          (void) CyIntSetVector(USB_EP_0_VECT_NUM,   &USB_EP_0_ISR);
 337   1      
 338   1          /* Set SOF interrupt. */
 339   1          #if (USB_SOF_ISR_ACTIVE)
 340   1              CyIntSetPriority     (USB_SOF_VECT_NUM,  USB_SOF_PRIOR);
 341   1              (void) CyIntSetVector(USB_SOF_VECT_NUM, &USB_SOF_ISR);
 342   1          #endif /* (USB_SOF_ISR_ACTIVE) */
 343   1      
 344   1          /* Set Data Endpoint 1 Interrupt. */
 345   1          #if (USB_EP1_ISR_ACTIVE)
 346   1              CyIntSetPriority     (USB_EP_1_VECT_NUM,  USB_EP_1_PRIOR);
 347   1              (void) CyIntSetVector(USB_EP_1_VECT_NUM,  &USB_EP_1_ISR);
 348   1          #endif /* (USB_EP1_ISR_ACTIVE) */
 349   1      
 350   1          /* Set Data Endpoint 2 Interrupt. */
 351   1          #if (USB_EP2_ISR_ACTIVE)
 352   1              CyIntSetPriority     (USB_EP_2_VECT_NUM,  USB_EP_2_PRIOR);
 353   1              (void) CyIntSetVector(USB_EP_2_VECT_NUM, &USB_EP_2_ISR);
 354   1          #endif /* (USB_EP2_ISR_ACTIVE) */
 355   1      
 356   1          /* Set Data Endpoint 3 Interrupt. */
 357   1          #if (USB_EP3_ISR_ACTIVE)
                      CyIntSetPriority     (USB_EP_3_VECT_NUM,  USB_EP_3_PRIOR);
                      (void) CyIntSetVector(USB_EP_3_VECT_NUM, &USB_EP_3_ISR);
                  #endif /* (USB_EP3_ISR_ACTIVE) */
 361   1      
 362   1          /* Set Data Endpoint 4 Interrupt. */
 363   1          #if (USB_EP4_ISR_ACTIVE)
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 7   

                      CyIntSetPriority     (USB_EP_4_VECT_NUM,  USB_EP_4_PRIOR);
                      (void) CyIntSetVector(USB_EP_4_VECT_NUM, &USB_EP_4_ISR);
                  #endif /* (USB_EP4_ISR_ACTIVE) */
 367   1      
 368   1          /* Set Data Endpoint 5 Interrupt. */
 369   1          #if (USB_EP5_ISR_ACTIVE)
                      CyIntSetPriority     (USB_EP_5_VECT_NUM,  USB_EP_5_PRIOR);
                      (void) CyIntSetVector(USB_EP_5_VECT_NUM, &USB_EP_5_ISR);
                  #endif /* (USB_EP5_ISR_ACTIVE) */
 373   1      
 374   1          /* Set Data Endpoint 6 Interrupt. */
 375   1          #if (USB_EP6_ISR_ACTIVE)
                      CyIntSetPriority     (USB_EP_6_VECT_NUM,  USB_EP_6_PRIOR);
                      (void) CyIntSetVector(USB_EP_6_VECT_NUM, &USB_EP_6_ISR);
                  #endif /* (USB_EP6_ISR_ACTIVE) */
 379   1      
 380   1           /* Set Data Endpoint 7 Interrupt. */
 381   1          #if (USB_EP7_ISR_ACTIVE)
                      CyIntSetPriority     (USB_EP_7_VECT_NUM,  USB_EP_7_PRIOR);
                      (void) CyIntSetVector(USB_EP_7_VECT_NUM, &USB_EP_7_ISR);
                  #endif /* (USB_EP7_ISR_ACTIVE) */
 385   1      
 386   1          /* Set Data Endpoint 8 Interrupt. */
 387   1          #if (USB_EP8_ISR_ACTIVE)
                      CyIntSetPriority     (USB_EP_8_VECT_NUM,  USB_EP_8_PRIOR);
                      (void) CyIntSetVector(USB_EP_8_VECT_NUM, &USB_EP_8_ISR);
                  #endif /* (USB_EP8_ISR_ACTIVE) */
 391   1      
 392   1          /* Set ARB Interrupt. */
 393   1          #if (USB_EP_MANAGEMENT_DMA && USB_ARB_ISR_ACTIVE)
                      CyIntSetPriority     (USB_ARB_VECT_NUM,  USB_ARB_PRIOR);
                      (void) CyIntSetVector(USB_ARB_VECT_NUM, &USB_ARB_ISR);
                  #endif /* (USB_EP_MANAGEMENT_DMA && USB_ARB_ISR_ACTIVE) */
 397   1      #endif /* (CY_PSOC4) */
 398   1      
 399   1          /* Common: Configure GPIO interrupt for wakeup. */
 400   1      #if (USB_DP_ISR_ACTIVE)
 401   1          CyIntSetPriority     (USB_DP_INTC_VECT_NUM,  USB_DP_INTC_PRIORITY);
 402   1          (void) CyIntSetVector(USB_DP_INTC_VECT_NUM, &USB_DP_ISR);
 403   1      #endif /* (USB_DP_ISR_ACTIVE) */
 404   1      
 405   1      #if (USB_EP_MANAGEMENT_DMA && CY_PSOC4)
                  /* Initialize DMA channels. */
                  USB_InitEpDma();
              #endif /* (USB_EP_MANAGEMENT_DMA && CY_PSOC4) */
 409   1      }
 410          
 411          
 412          /*******************************************************************************
 413          * Function Name: USB_InitComponent
 414          ****************************************************************************//**
 415          *
 416          *   This function initializes the component’s global variables and initiates
 417          *   communication with the host by pull-up D+ line.
 418          *
 419          * \param device:
 420          *   Contains the device number of the desired device descriptor. The device
 421          *   number can be found in the Device Descriptor Tab of "Configure" dialog,
 422          *   under the settings of desired Device Descriptor, in the *Device Number*
 423          *   field.
 424          *  \param mode:
 425          *   The operating voltage. This determines whether the voltage regulator
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 8   

 426          *   is enabled for 5V operation or if pass through mode is used for 3.3V
 427          *   operation. Symbolic names and their associated values are given in the
 428          *   following list.
 429          *
 430          *       *USB_3V_OPERATION* - Disable voltage regulator and pass-
 431          *                                      through Vcc for pull-up
 432          *
 433          *       *USB_5V_OPERATION* - Enable voltage regulator and use
 434          *                                      regulator for pull-up
 435          *
 436          *       *USB_DWR_POWER_OPERATION* - Enable or disable the voltage
 437          *                                      regulator depending on the power supply
 438          *                                      voltage configuration in the DWR tab.
 439          *                                      For PSoC 3/5LP devices, the VDDD supply
 440          *                                      voltage is considered and for PSoC 4A-L,
 441          *                                      the VBUS supply voltage is considered.
 442          *
 443          * \globalvars
 444          *   \ref USB_device
 445          *   \ref USB_transferState
 446          *   \ref USB_configuration
 447          *   \ref USB_deviceStatus
 448          *
 449          *   \ref USB_deviceAddress - Contains the current device address. This
 450          *       variable is initialized to zero in this API. The Host starts to communicate
 451          *      to the device with address 0 and then sets it to a whatever value using a
 452          *      SET_ADDRESS request.
 453          *
 454          *   \ref USB_lastPacketSize - Initialized to 0;
 455          *
 456          * \reentrant
 457          *  No.
 458          *
 459          *******************************************************************************/
 460          void USB_InitComponent(uint8 device, uint8 mode) 
 461          {
 462   1          /* Initialize _hidProtocol variable to comply with
 463   1          *  HID 7.2.6 Set_Protocol Request:
 464   1          *  "When initialized, all devices default to report protocol."
 465   1          */
 466   1      #if defined(USB_ENABLE_HID_CLASS)
                  uint8 i;
              
                  for (i = 0u; i < USB_MAX_INTERFACES_NUMBER; i++)
                  {
                      USB_hidProtocol[i] = USB_PROTOCOL_REPORT;
                  }
              #endif /* USB_ENABLE_HID_CLASS */
 474   1      
 475   1          /* Store device number to access descriptor. */
 476   1          USB_device = device;
 477   1      
 478   1          /* Reset component internal variables. */
 479   1          USB_transferState   = USB_TRANS_STATE_IDLE;
 480   1          USB_configurationChanged = 0u;
 481   1          USB_configuration   = 0u;
 482   1          USB_interfaceNumber = 0u;
 483   1          USB_deviceAddress   = 0u;
 484   1          USB_deviceStatus    = 0u;
 485   1          USB_lastPacketSize  = 0u;
 486   1      
 487   1          /* Enable component interrupts. */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 9   

 488   1      #if (CY_PSOC4)
                  CyIntEnable(USB_INTR_HI_VECT_NUM);
                  CyIntEnable(USB_INTR_MED_VECT_NUM);
                  CyIntEnable(USB_INTR_LO_VECT_NUM);
              #else
 493   1          CyIntEnable(USB_BUS_RESET_VECT_NUM);
 494   1          CyIntEnable(USB_EP_0_VECT_NUM);
 495   1      
 496   1          #if (USB_SOF_ISR_ACTIVE)
 497   1              CyIntEnable(USB_SOF_VECT_NUM);
 498   1          #endif /* (USB_SOF_ISR_ACTIVE) */
 499   1      
 500   1          #if (USB_EP1_ISR_ACTIVE)
 501   1              CyIntEnable(USB_EP_1_VECT_NUM);
 502   1          #endif /* (USB_EP1_ISR_ACTIVE) */
 503   1      
 504   1          #if (USB_EP2_ISR_ACTIVE)
 505   1              CyIntEnable(USB_EP_2_VECT_NUM);
 506   1          #endif /* (USB_EP5_ISR_ACTIVE) */
 507   1      
 508   1          #if (USB_EP3_ISR_ACTIVE)
                      CyIntEnable(USB_EP_3_VECT_NUM);
                  #endif /* (USB_EP5_ISR_ACTIVE) */
 511   1      
 512   1          #if (USB_EP4_ISR_ACTIVE)
                      CyIntEnable(USB_EP_4_VECT_NUM);
                  #endif /* (USB_EP5_ISR_ACTIVE) */
 515   1      
 516   1          #if (USB_EP5_ISR_ACTIVE)
                      CyIntEnable(USB_EP_5_VECT_NUM);
                  #endif /* (USB_EP5_ISR_ACTIVE) */
 519   1      
 520   1          #if (USB_EP6_ISR_ACTIVE)
                      CyIntEnable(USB_EP_6_VECT_NUM);
                  #endif /* USB_EP6_ISR_REMOVE */
 523   1      
 524   1          #if (USB_EP7_ISR_ACTIVE)
                      CyIntEnable(USB_EP_7_VECT_NUM);
                  #endif /* (USB_EP7_ISR_ACTIVE) */
 527   1      
 528   1          #if (USB_EP8_ISR_ACTIVE)
                      CyIntEnable(USB_EP_8_VECT_NUM);
                  #endif /* (USB_EP8_ISR_ACTIVE) */
 531   1      #endif /* (CY_PSOC4) */
 532   1      
 533   1      #if (USB_EP_MANAGEMENT_DMA && USB_ARB_ISR_ACTIVE)
                  /* Enable ARB EP interrupt sources. */
                  USB_ARB_INT_EN_REG = USB_DEFAULT_ARB_INT_EN;
              
                  #if (CY_PSOC3 || CY_PSOC5)
                      CyIntEnable(USB_ARB_VECT_NUM);
                  #endif /* (CY_PSOC3 || CY_PSOC5) */
              #endif   /* (USB_EP_MANAGEMENT_DMA && USB_ARB_ISR_ACTIVE) */
 541   1      
 542   1      /* Arbiter configuration for DMA transfers. */
 543   1      #if (USB_EP_MANAGEMENT_DMA)
                  /* Configure Arbiter for Manual or Auto DMA operation and clear configuration completion. */
                  USB_ARB_CFG_REG = USB_DEFAULT_ARB_CFG;
              
                  #if (CY_PSOC4)
                      /* Enable DMA operation. */
                      CyDmaEnable();
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 10  

              
                      #if (USB_EP_MANAGEMENT_DMA_AUTO)
                          /* Change DMA priority to be highest. */
                           CyIntSetPriority(CYDMA_INTR_NUMBER, USB_DMA_AUTO_INTR_PRIO);
                      #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (CY_PSOC4) */
              
                  #if (USB_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                          /* Enable DMA interrupt to handle DMA management. */
                          CyIntEnable(CYDMA_INTR_NUMBER);
                      #else
                          #if (USB_EP_DMA_AUTO_OPT == 0u)
                              /* Initialize interrupts which handle verification of successful DMA transaction. */
                              USB_EP_DMA_Done_isr_StartEx(&USB_EP_DMA_DONE_ISR);
                              USB_EP17_DMA_Done_SR_InterruptEnable();
                              USB_EP8_DMA_Done_SR_InterruptEnable();
                          #endif /* (USB_EP_DMA_AUTO_OPT == 0u) */
                      #endif /* (CY_PSOC4) */
                  #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
              #endif /* (USB_EP_MANAGEMENT_DMA) */
 571   1      
 572   1          /* Enable USB regulator depends on operation voltage. IMO Locking is enabled in Init(). */
 573   1          switch(mode)
 574   1          {
 575   2          case USB_3V_OPERATION:
 576   2              /* Disable regulator for 3V operation. */
 577   2              USB_CR1_REG &= (uint8) ~USB_CR1_REG_ENABLE;
 578   2              break;
 579   2      
 580   2          case USB_5V_OPERATION:
 581   2              /* Enable regulator for 5V operation. */
 582   2              USB_CR1_REG |= (uint8)  USB_CR1_REG_ENABLE;
 583   2              break;
 584   2      
 585   2          default: /* Check DWR settings of USB power supply. */
 586   2          #if (USB_VDDD_MV < USB_3500MV)
                      /* Disable regulator for 3V operation. */
                      USB_CR1_REG &= (uint8) ~USB_CR1_REG_ENABLE;
                  #else
 590   2              /* Enable regulator for 5V operation. */
 591   2              USB_CR1_REG |= (uint8)  USB_CR1_REG_ENABLE;
 592   2          #endif /* (USB_VDDD_MV < USB_3500MV) */
 593   2              break;
 594   2          }
 595   1      
 596   1      #if (CY_PSOC4)
                  /* Clear bus activity. */
                  USB_CR1_REG &= (uint32) ~USB_CR1_BUS_ACTIVITY;
              
                  /* Clear EP0 count register. */
                  USB_EP0_CNT_REG = USB_CLEAR_REG;
              
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USB_EP0_CR_REG = USB_MODE_NAK_IN_OUT;
              
                  #if (USB_LPM_ACTIVE)
                      if (NULL != USB_GetBOSPtr())
                      {
                          /* Enable LPM and acknowledge LPM packets for active device.
                          * Reset NYET_EN and SUB_RESP bits in the LPM_CTRL register.
                          */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 11  

                          USB_LPM_CTRL_REG = (USB_LPM_CTRL_LPM_EN | \
                                                           USB_LPM_CTRL_LPM_ACK_RESP);
                      }
                      else
                      {
                          /* Disable LPM for active device. */
                          USB_LPM_CTRL_REG &= (uint32) ~USB_LPM_CTRL_LPM_EN;
                      }
                  #endif /* (USB_LPM_ACTIVE) */
              
                  /* Enable device to responds to USB traffic with address 0. */
                  USB_CR0_REG = USB_DEFUALT_CR0;
              
              #else
 626   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 627   1          USB_EP0_CR_REG = USB_MODE_STALL_IN_OUT;
 628   1      
 629   1          /* Enable device to respond to USB traffic with address 0. */
 630   1          USB_CR0_REG = USB_DEFUALT_CR0;
 631   1          CyDelayCycles(USB_WAIT_CR0_REG_STABILITY);
 632   1      #endif /* (CY_PSOC4) */
 633   1      
 634   1          /* Enable D+ pull-up and keep USB control on IO. */
 635   1          USB_USBIO_CR1_REG = USB_USBIO_CR1_USBPUEN;
 636   1      }
 637          
 638          
 639          /*******************************************************************************
 640          * Function Name: USB_ReInitComponent
 641          ****************************************************************************//**
 642          *
 643          *  This function reinitialize the component configuration and is
 644          *  intend to be called from the Reset interrupt.
 645          *
 646          * \globalvars
 647          *   USB_device - Contains the device number of the desired Device
 648          *        Descriptor. The device number can be found in the Device Descriptor tab
 649          *       of the Configure dialog, under the settings of the desired Device Descriptor,
 650          *       in the Device Number field.
 651          *   USB_transferState - This variable is used by the communication
 652          *       functions to handle the current transfer state. Initialized to
 653          *       TRANS_STATE_IDLE in this API.
 654          *   USB_configuration - Contains the current configuration number
 655          *       set by the Host using a SET_CONFIGURATION request.
 656          *       Initialized to zero in this API.
 657          *   USB_deviceAddress - Contains the current device address. This
 658          *       variable is initialized to zero in this API. The Host starts to communicate
 659          *      to the device with address 0 and then sets it to a whatever value using
 660          *      a SET_ADDRESS request.
 661          *   USB_deviceStatus - Initialized to 0.
 662          *       This is a two-bit variable which contains the power status in the first bit
 663          *       (DEVICE_STATUS_BUS_POWERED or DEVICE_STATUS_SELF_POWERED) and the remote
 664          *       wakeup status (DEVICE_STATUS_REMOTE_WAKEUP) in the second bit.
 665          *   USB_lastPacketSize - Initialized to 0;
 666          *
 667          * \reentrant
 668          *  No.
 669          *
 670          *******************************************************************************/
 671          void USB_ReInitComponent(void) 
 672          {
 673   1          /* Initialize _hidProtocol variable to comply with HID 7.2.6 Set_Protocol
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 12  

 674   1          *  Request: "When initialized, all devices default to report protocol."
 675   1          */
 676   1      #if defined(USB_ENABLE_HID_CLASS)
                  uint8 i;
              
                  for (i = 0u; i < USB_MAX_INTERFACES_NUMBER; i++)
                  {
                      USB_hidProtocol[i] = USB_PROTOCOL_REPORT;
                  }
              #endif /* USB_ENABLE_HID_CLASS */
 684   1      
 685   1          /* Reset component internal variables. */
 686   1          USB_transferState   = USB_TRANS_STATE_IDLE;
 687   1          USB_configurationChanged = 0u;
 688   1          USB_configuration   = 0u;
 689   1          USB_interfaceNumber = 0u;
 690   1          USB_deviceAddress   = 0u;
 691   1          USB_deviceStatus    = 0u;
 692   1          USB_lastPacketSize  = 0u;
 693   1      
 694   1      #if (CY_PSOC4)
                  /* Set EP0.CR: ACK Setup, NAK IN/OUT. */
                  USB_EP0_CR_REG = USB_MODE_NAK_IN_OUT;
              #else
 698   1          /* Set EP0.CR: ACK Setup, STALL IN/OUT. */
 699   1          USB_EP0_CR_REG = USB_MODE_STALL_IN_OUT;
 700   1      #endif /* (CY_PSOC4) */
 701   1      
 702   1          /* Enable device to respond to USB traffic with address 0. */
 703   1          USB_CR0_REG = USB_DEFUALT_CR0;
 704   1      }
 705          
 706          
 707          /*******************************************************************************
 708          * Function Name: USB_Stop
 709          ****************************************************************************//**
 710          *
 711          *  This function shuts down the USB function including to release
 712          *  the D+ pull-up and disabling the SIE.
 713          *
 714          * \globalvars
 715          *   \ref USB_configuration
 716          *
 717          *   USB_deviceAddress - Contains the current device address. This
 718          *       variable is initialized to zero in this API. The Host starts to communicate
 719          *      to the device with address 0 and then sets it to a whatever value using
 720          *      a SET_ADDRESS request.
 721          *
 722          *   \ref USB_deviceStatus
 723          *
 724          *   \ref USB_configurationChanged
 725          *
 726          *   USB_intiVar -  This variable is set to zero
 727          *
 728          *******************************************************************************/
 729          void USB_Stop(void) 
 730          {
 731   1          uint8 enableInterrupts;
 732   1      
 733   1      #if (USB_EP_MANAGEMENT_DMA)
                  /* Stop all DMA channels. */
                  USB_Stop_DMA(USB_MAX_EP);
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 13  

              #endif /* (USB_EP_MANAGEMENT_DMA) */
 737   1      
 738   1          enableInterrupts = CyEnterCriticalSection();
 739   1      
 740   1          /* Disable USB IP to respond to USB traffic. */
 741   1          USB_CR0_REG &= (uint8) ~USB_CR0_ENABLE;
 742   1      
 743   1          /* Disable D+ pull-up. */
 744   1          USB_USBIO_CR1_REG &= (uint8) ~ USB_USBIO_CR1_USBPUEN;
 745   1      
 746   1      #if (CY_PSOC4)
                  /* Disable USBFS block. */
                  USB_POWER_CTRL_REG &= (uint32) ~USB_POWER_CTRL_ENABLE;
              #else
 750   1          /* Clear power active and standby mode templates. */
 751   1          USB_PM_ACT_CFG_REG  &= (uint8) ~USB_PM_ACT_EN_FSUSB;
 752   1          USB_PM_STBY_CFG_REG &= (uint8) ~USB_PM_STBY_EN_FSUSB;
 753   1      
 754   1          /* Ensure single-ended disable bits are high (PRT15.INP_DIS[7:6])
 755   1           * (input receiver disabled). */
 756   1          USB_DM_INP_DIS_REG |= (uint8) USB_DM_MASK;
 757   1          USB_DP_INP_DIS_REG |= (uint8) USB_DP_MASK;
 758   1      
 759   1      #endif /* (CY_PSOC4) */
 760   1      
 761   1          CyExitCriticalSection(enableInterrupts);
 762   1      
 763   1          /* Disable component interrupts. */
 764   1      #if (CY_PSOC4)
                  CyIntDisable(USB_INTR_HI_VECT_NUM);
                  CyIntDisable(USB_INTR_LO_VECT_NUM);
                  CyIntDisable(USB_INTR_MED_VECT_NUM);
              #else
 769   1      
 770   1          CyIntDisable(USB_BUS_RESET_VECT_NUM);
 771   1          CyIntDisable(USB_EP_0_VECT_NUM);
 772   1      
 773   1          #if (USB_SOF_ISR_ACTIVE)
 774   1              CyIntDisable(USB_SOF_VECT_NUM);
 775   1          #endif /* (USB_SOF_ISR_ACTIVE) */
 776   1      
 777   1          #if (USB_EP1_ISR_ACTIVE)
 778   1              CyIntDisable(USB_EP_1_VECT_NUM);
 779   1          #endif /* (USB_EP1_ISR_ACTIVE) */
 780   1      
 781   1          #if (USB_EP2_ISR_ACTIVE)
 782   1              CyIntDisable(USB_EP_2_VECT_NUM);
 783   1          #endif /* (USB_EP2_ISR_ACTIVE) */
 784   1      
 785   1          #if (USB_EP3_ISR_ACTIVE)
                      CyIntDisable(USB_EP_3_VECT_NUM);
                  #endif /* (USB_EP3_ISR_ACTIVE) */
 788   1      
 789   1          #if (USB_EP4_ISR_ACTIVE)
                      CyIntDisable(USB_EP_4_VECT_NUM);
                  #endif /* (USB_EP4_ISR_ACTIVE) */
 792   1      
 793   1          #if (USB_EP5_ISR_ACTIVE)
                      CyIntDisable(USB_EP_5_VECT_NUM);
                  #endif /* (USB_EP5_ISR_ACTIVE) */
 796   1      
 797   1          #if (USB_EP6_ISR_ACTIVE)
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 14  

                      CyIntDisable(USB_EP_6_VECT_NUM);
                  #endif /* USB_EP6_ISR_REMOVE */
 800   1      
 801   1          #if (USB_EP7_ISR_ACTIVE)
                      CyIntDisable(USB_EP_7_VECT_NUM);
                  #endif /* (USB_EP7_ISR_ACTIVE) */
 804   1      
 805   1          #if (USB_EP8_ISR_ACTIVE)
                      CyIntDisable(USB_EP_8_VECT_NUM);
                  #endif /* (USB_EP8_ISR_ACTIVE) */
 808   1      
 809   1          #if (USB_DP_ISR_ACTIVE)
 810   1              /* Clear active mode Dp interrupt source history. */
 811   1              (void) USB_Dp_ClearInterrupt();
 812   1              CyIntClearPending(USB_DP_INTC_VECT_NUM);
 813   1          #endif /* (USB_DP_ISR_ACTIVE). */
 814   1      
 815   1      #endif /* (CY_PSOC4) */
 816   1      
 817   1          /* Reset component internal variables. */
 818   1          USB_configurationChanged = 0u;
 819   1          USB_configuration   = 0u;
 820   1          USB_interfaceNumber = 0u;
 821   1          USB_deviceAddress   = 0u;
 822   1          USB_deviceStatus    = 0u;
 823   1      
 824   1          /* It is mandatory for correct device startup. */
 825   1          USB_initVar = 0u;
 826   1      }
 827          
 828          
 829          /*******************************************************************************
 830          * Function Name: USB_CheckActivity
 831          ****************************************************************************//**
 832          *
 833          *  This function returns the activity status of the bus. It clears the hardware
 834          *  status to provide updated status on the next call of this function. It
 835          *  provides a way to determine whether any USB bus activity occurred. The
 836          *  application should use this function to determine if the USB suspend
 837          *  conditions are met.
 838          *
 839          *
 840          * \return
 841          *  cystatus: Status of the bus since the last call of the function.
 842          *  Return Value |   Description
 843          *  -------------|---------------------------------------------------------------
 844          *  1            |Bus activity was detected since the last call to this function
 845          *  0            |Bus activity was not detected since the last call to this function
 846          *
 847          *
 848          *******************************************************************************/
 849          uint8 USB_CheckActivity(void) 
 850          {
 851   1          uint8 cr1Reg = USB_CR1_REG;
 852   1      
 853   1          /* Clear bus activity. */
 854   1          USB_CR1_REG = (cr1Reg & (uint8) ~USB_CR1_BUS_ACTIVITY);
 855   1      
 856   1          /* Get bus activity. */
 857   1          return ((0u != (cr1Reg & USB_CR1_BUS_ACTIVITY)) ? (1u) : (0u));
 858   1      }
 859          
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 15  

 860          
 861          /*******************************************************************************
 862          * Function Name: USB_GetConfiguration
 863          ****************************************************************************//**
 864          *
 865          *  This function gets the current configuration of the USB device.
 866          *
 867          * \return
 868          *  Returns the currently assigned configuration. Returns 0 if the device
 869          *  is not configured
 870          *
 871          *******************************************************************************/
 872          uint8 USB_GetConfiguration(void) 
 873          {
 874   1          return (USB_configuration);
 875   1      }
 876          
 877          
 878          /*******************************************************************************
 879          * Function Name: USB_IsConfigurationChanged
 880          ****************************************************************************//**
 881          *
 882          *  This function returns the clear-on-read configuration state.  It is useful
 883          *  when the host sends double SET_CONFIGURATION request with the same 
 884          *  configuration number or changes alternate settings of the interface. 
 885          *  After configuration has been changed the OUT endpoints must be enabled and IN 
 886          *  endpoint must be loaded with data to start communication with the host.
 887          *
 888          * \return
 889          *  None-zero value when new configuration has been changed, otherwise zero is
 890          *  returned.
 891          *
 892          * \globalvars
 893          *
 894          *  \ref USB_configurationChanged - This variable is set to 1 after
 895          *   a SET_CONFIGURATION request and cleared in this function.
 896          *
 897          *******************************************************************************/
 898          uint8 USB_IsConfigurationChanged(void) 
 899          {
 900   1          uint8 res = 0u;
 901   1      
 902   1          if (USB_configurationChanged != 0u)
 903   1          {
 904   2              res = USB_configurationChanged;
 905   2              USB_configurationChanged = 0u;
 906   2          }
 907   1      
 908   1          return (res);
 909   1      }
 910          
 911          
 912          /*******************************************************************************
 913          * Function Name: USB_GetInterfaceSetting
 914          ****************************************************************************//**
 915          *
 916          *  This function gets the current alternate setting for the specified interface.
 917          *  It is useful to identify which alternate settings are active in the specified 
 918          *  interface.
 919          *
 920          *  \param
 921          *  interfaceNumber interface number
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 16  

 922          *
 923          * \return
 924          *  Returns the current alternate setting for the specified interface.
 925          *
 926          *******************************************************************************/
 927          uint8  USB_GetInterfaceSetting(uint8 interfaceNumber)
 928                                                              
 929          {
 930   1          return (USB_interfaceSetting[interfaceNumber]);
 931   1      }
 932          
 933          
 934          /*******************************************************************************
 935          * Function Name: USB_GetEPState
 936          ****************************************************************************//**
 937          *
 938          *  This function returns the state of the requested endpoint.
 939          *
 940          * \param epNumber Data endpoint number
 941          *
 942          * \return
 943          *  Returns the current state of the specified USBFS endpoint. Symbolic names and
 944          *  their associated values are given in the following table. Use these constants
 945          *  whenever you write code to change the state of the endpoints, such as ISR
 946          *  code, to handle data sent or received.
 947          *
 948          *  Return Value           | Description
 949          *  -----------------------|-----------------------------------------------------
 950          *  USBFS_NO_EVENT_PENDING |The endpoint is awaiting SIE action
 951          *  USBFS_EVENT_PENDING    |The endpoint is awaiting CPU action
 952          *  USBFS_NO_EVENT_ALLOWED |The endpoint is locked from access
 953          *  USBFS_IN_BUFFER_FULL   |The IN endpoint is loaded and the mode is set to ACK IN
 954          *  USBFS_IN_BUFFER_EMPTY  |An IN transaction occurred and more data can be loaded
 955          *  USBFS_OUT_BUFFER_EMPTY |The OUT endpoint is set to ACK OUT and is waiting for data
 956          *  USBFS_OUT_BUFFER_FULL  |An OUT transaction has occurred and data can be read
 957          *
 958          *******************************************************************************/
 959          uint8 USB_GetEPState(uint8 epNumber) CYREENTRANT
 960          {
 961   1          return (USB_EP[epNumber].apiEpState);
 962   1      }
 963          
 964          
 965          /*******************************************************************************
 966          * Function Name: USB_GetEPCount
 967          ****************************************************************************//**
 968          *
 969          *  This function supports Data Endpoints only(EP1-EP8).
 970          *  Returns the transfer count for the requested endpoint.  The value from
 971          *  the count registers includes 2 counts for the two byte checksum of the
 972          *  packet.  This function subtracts the two counts.
 973          *
 974          *  \param epNumber Data Endpoint Number.
 975          *                   Valid values are between 1 and 8.
 976          *
 977          * \return
 978          *  Returns the current byte count from the specified endpoint or 0 for an
 979          *  invalid endpoint.
 980          *
 981          *******************************************************************************/
 982          uint16 USB_GetEPCount(uint8 epNumber) CYREENTRANT
 983          {
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 17  

 984   1          uint16 cntr = 0u;
 985   1      
 986   1          if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
 987   1          {
 988   2              /* Get 11-bits EP counter where epCnt0 - 3 bits MSB and epCnt1 - 8 bits LSB. */
 989   2              cntr  = ((uint16) USB_SIE_EP_BASE.sieEp[epNumber].epCnt0) & USB_EPX_CNT0_MASK;
 990   2              cntr  = ((uint16) (cntr << 8u)) | ((uint16) USB_SIE_EP_BASE.sieEp[epNumber].epCnt1);
 991   2              cntr -= USB_EPX_CNTX_CRC_COUNT;
 992   2          }
 993   1      
 994   1          return (cntr);
 995   1      }
 996          
 997          
 998          #if (USB_EP_MANAGEMENT_DMA)
              #if (CY_PSOC4)
                  /*******************************************************************************
                  * Function Name: USB_InitEpDma
                  ****************************************************************************//**
                  *
                  *  This function configures priority for all DMA channels utilized by the
                  *  component. Also sets callbacks for DMA auto mode.
                  *
                  *******************************************************************************/
                  static void USB_InitEpDma(void)
                  {
                  #if (USB_DMA1_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep1_dma_CHANNEL] = USB_ep1_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA1_ACTIVE) */
              
                  #if (USB_DMA2_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep2_dma_CHANNEL] = USB_ep2_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA2_ACTIVE) */
              
                  #if (USB_DMA3_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep3_dma_CHANNEL] = USB_ep3_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA3_ACTIVE) */
              
                  #if (USB_DMA4_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep4_dma_CHANNEL] = USB_ep4_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA4_ACTIVE) */
              
                  #if (USB_DMA5_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep5_dma_CHANNEL] = USB_ep5_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA5_ACTIVE) */
              
                  #if (USB_DMA6_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep6_dma_CHANNEL] = USB_ep6_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA6_ACTIVE) */
              
                  #if (USB_DMA7_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep7_dma_CHANNEL] = USB_ep7_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA7_ACTIVE) */
              
                  #if (USB_DMA8_ACTIVE)
                      CYDMA_CH_CTL_BASE.ctl[USB_ep8_dma_CHANNEL] = USB_ep8_dma_CHANNEL_CFG;
                  #endif /* (USB_DMA8_ACTIVE) */
              
                  #if (USB_EP_MANAGEMENT_DMA_AUTO)
                      /* Initialize DMA channel callbacks. */
                      #if (USB_DMA1_ACTIVE)
                          (void) USB_ep1_dma_SetInterruptCallback(&USB_EP1_DMA_DONE_ISR);
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 18  

                      #endif /* (USB_DMA1_ACTIVE) */
              
                      #if (USB_DMA2_ACTIVE)
                          (void) USB_ep2_dma_SetInterruptCallback(&USB_EP2_DMA_DONE_ISR);
                      #endif /* (USB_DMA2_ACTIVE) */
              
                      #if (USB_DMA3_ACTIVE)
                          (void) USB_ep3_dma_SetInterruptCallback(&USB_EP3_DMA_DONE_ISR);
                      #endif /* (USB_DMA3_ACTIVE) */
              
                      #if (USB_DMA4_ACTIVE)
                          (void) USB_ep4_dma_SetInterruptCallback(&USB_EP4_DMA_DONE_ISR);
                      #endif /* (USB_DMA4_ACTIVE) */
              
                      #if (USB_DMA5_ACTIVE)
                          (void) USB_ep5_dma_SetInterruptCallback(&USB_EP5_DMA_DONE_ISR);
                      #endif /* (USB_DMA5_ACTIVE) */
              
                      #if (USB_DMA6_ACTIVE)
                          (void) USB_ep6_dma_SetInterruptCallback(&USB_EP6_DMA_DONE_ISR);
                      #endif /* (USB_DMA6_ACTIVE) */
              
                      #if (USB_DMA7_ACTIVE)
                          (void) USB_ep7_dma_SetInterruptCallback(&USB_EP7_DMA_DONE_ISR);
                      #endif /* (USB_DMA7_ACTIVE) */
              
                      #if (USB_DMA8_ACTIVE)
                          (void) USB_ep8_dma_SetInterruptCallback(&USB_EP8_DMA_DONE_ISR);
                      #endif /* (USB_DMA8_ACTIVE) */
                  #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
                  }
              #else
              
              
                  /***************************************************************************
                  * Function Name: USB_InitEP_DMA
                  ************************************************************************//**
                  *
                  *  This function allocates and initializes a DMA channel to be used by the
                  *  USB_LoadInEP() or USB_ReadOutEP() APIs for data
                  *  transfer. It is available when the Endpoint Memory Management parameter
                  *  is set to DMA.
                  *
                  *  This function is automatically called from the USBFS_LoadInEP() and USBFS_ReadOutEP() APIs.
                  *
                  *  \param epNumber Contains the data endpoint number.
                  *            Valid values are between 1 and 8.
                  *  \param *pData Pointer to a data array that is related to the EP transfers.
                  *
                  * \reentrant No.
                  *
                  ***************************************************************************/
                  void USB_InitEP_DMA(uint8 epNumber, const uint8 *pData)
                                                                                  CYREENTRANT
                  {
                      uint16 src;
                      uint16 dst;
              
                  #if (CY_PSOC3)
                      src = HI16(CYDEV_SRAM_BASE);
                      dst = HI16(CYDEV_PERIPH_BASE);
                      pData = pData;
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 19  

                  #else
                      if ((USB_EP[epNumber].addr & USB_DIR_IN) != 0u)
                      {
                          /* IN endpoint: source is memory buffer. */
                          src = HI16(pData);
                          dst = HI16(CYDEV_PERIPH_BASE);
                      }
                      else
                      {
                          /* OUT endpoint: source is USB IP memory buffer. */
                          src = HI16(CYDEV_PERIPH_BASE);
                          dst = HI16(pData);
                      }
                  #endif  /* (CY_PSOC3) */
              
                      switch(epNumber)
                      {
                  #if (USB_DMA1_ACTIVE)
                      case USB_EP1:
                          USB_DmaChan[epNumber] = USB_ep1_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                  USB_DMA_REQUEST_PER_BU
             -RST, src, dst);
                          break;
                  #endif /* (USB_DMA1_ACTIVE) */
              
                  #if (USB_DMA2_ACTIVE)
                      case USB_EP2:
                          USB_DmaChan[epNumber] = USB_ep2_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                  USB_DMA_REQUEST_PER_BU
             -RST, src, dst);
                          break;
                  #endif /* (USB_DMA2_ACTIVE) */
              
                  #if (USB_DMA3_ACTIVE)
                          case USB_EP3:
                              USB_DmaChan[epNumber] = USB_ep3_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                      USB_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USB_DMA3_ACTIVE) */
              
                  #if (USB_DMA4_ACTIVE)
                          case USB_EP4:
                              USB_DmaChan[epNumber] = USB_ep4_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                      USB_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USB_DMA4_ACTIVE) */
              
                  #if (USB_DMA5_ACTIVE)
                          case USB_EP5:
                              USB_DmaChan[epNumber] = USB_ep5_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                      USB_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USB_DMA5_ACTIVE) */
              
                  #if (USB_DMA6_ACTIVE)
                      case USB_EP6:
                          USB_DmaChan[epNumber] = USB_ep6_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                  USB_DMA_REQUEST_PER_BU
             -RST, src, dst);
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 20  

                          break;
                  #endif /* (USB_DMA6_ACTIVE) */
              
                  #if (USB_DMA7_ACTIVE)
                      case USB_EP7:
                              USB_DmaChan[epNumber] = USB_ep7_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                      USB_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USB_DMA7_ACTIVE) */
              
                  #if (USB_DMA8_ACTIVE)
                      case USB_EP8:
                              USB_DmaChan[epNumber] = USB_ep8_DmaInitialize(USB_DMA_BYTES_PER_BURST,
                                                                                                      USB_DMA_REQUEST_PE
             -R_BURST, src, dst);
                          break;
                  #endif /* (USB_DMA8_ACTIVE) */
              
                      default:
                          /* Do nothing for endpoints other than 1-8. */
                          break;
                      }
              
                      if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
                      {
                          USB_DmaTd[epNumber] = CyDmaTdAllocate();
              
                      #if (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u))
                          USB_DmaNextTd[epNumber] = CyDmaTdAllocate();
                      #endif /* (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u)) */
                      }
                  }
              #endif /* (CY_PSOC4) */
              
                  /***************************************************************************
                  * Function Name: USB_Stop_DMA
                  ************************************************************************//**
                  *  
                  *  This function stops DMA channel associated with endpoint. It is available 
                  *  when the Endpoint Buffer Management parameter is set to DMA. Call this 
                  *  function when endpoint direction is changed from IN to OUT or vice versa 
                  *  to trigger DMA re-configuration when USB_LoadInEP() or 
                  *  USB_ReadOutEP() functions are called the first time. 
                  *  
                  *  \param epNumber: The data endpoint number for which associated DMA 
                  *  channel is stopped. The range of valid values is between 1 and 8. To stop 
                  *  all DMAs associated with endpoints call this function with 
                  *  USB_MAX_EP argument.
                  *
                  * \reentrant
                  *  No.
                  *
                  ***************************************************************************/
                  void USB_Stop_DMA(uint8 epNumber) 
                  {
                      uint8 i;
              
                      i = (epNumber < USB_MAX_EP) ? epNumber : USB_EP1;
              
                      do
                      {
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 21  

                      #if (CY_PSOC4)
                          if (0u != USB_DmaChan[i])
                          {
                              USB_CyDmaChDisable(USB_DmaChan[i]);
                          }
                      #else
                          if(USB_DmaTd[i] != DMA_INVALID_TD)
                          {
                              (void) CyDmaChDisable(USB_DmaChan[i]);
                              CyDmaTdFree(USB_DmaTd[i]);
                              USB_DmaTd[i] = DMA_INVALID_TD;
                          }
              
                          #if (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u))
                              if(USB_DmaNextTd[i] != DMA_INVALID_TD)
                              {
                                  CyDmaTdFree(USB_DmaNextTd[i]);
                                  USB_DmaNextTd[i] = DMA_INVALID_TD;
                              }
                          #endif /* (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u)) */
              
                      #endif /* (CY_PSOC4) */
                          i++;
                      }
                      while ((i < USB_MAX_EP) && (epNumber == USB_MAX_EP));
                  }
              #endif /* (USB_EP_MANAGEMENT_DMA) */
1251          
1252          
1253          #if (CY_PSOC3 || CY_PSOC5)
1254          #if (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u))
                  /***************************************************************************
                  * Function Name: USB_LoadNextInEP
                  ************************************************************************//**
                  *
                  * Summary:
                  *  This internal function is used for IN endpoint DMA reconfiguration in
                  *  Auto DMA mode.
                  *
                  * Parameters:
                  *  epNumber: Contains the data endpoint number.
                  *  mode:   0 - Configure DMA to send the the rest of data.
                  *          1 - Configure DMA to repeat 2 last bytes of the first burst.
                  *
                  ***************************************************************************/
                  void USB_LoadNextInEP(uint8 epNumber, uint8 mode) CYREENTRANT
                  {
                      reg16 *convert;
              
                      if (mode == 0u)
                      {
                          /* Configure DMA to send rest of data. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USB_inLength[epNumber] - USB_DMA_BYTES_PER_BURST);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert, LO16((uint32)USB_inDataPointer[epNumber] +
                                                          USB_DMA_BYTES_PER_BURST));
                          USB_inBufFull[epNumber] = 1u;
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 22  

                      }
                      else
                      {
                          /* Configure DMA to repeat 2 last bytes of the first burst. */
                          /* CyDmaTdSetConfiguration API is optimized to change transfer length only and configure TD. *
             -/
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD0[0u];
                          /* Set transfer length. */
                          CY_SET_REG16(convert, USB_DMA_BYTES_REPEAT);
                          /* CyDmaTdSetAddress API is optimized to change source address only. */
                          convert = (reg16 *) &CY_DMA_TDMEM_STRUCT_PTR[USB_DmaTd[epNumber]].TD1[0u];
                          CY_SET_REG16(convert,  LO16((uint32)USB_inDataPointer[epNumber] +
                                                 (USB_DMA_BYTES_PER_BURST - USB_DMA_BYTES_REPEAT)));
                      }
              
                      /* CyDmaChSetInitialTd API is optimized to initialize TD. */
                      CY_DMA_CH_STRUCT_PTR[USB_DmaChan[epNumber]].basic_status[1u] = USB_DmaTd[epNumber];
                  }
              #endif /* (USB_EP_MANAGEMENT_DMA_AUTO && (USB_EP_DMA_AUTO_OPT == 0u)) */
1303          #endif /* (CY_PSOC3 || CY_PSOC5) */
1304          
1305          
1306          /*******************************************************************************
1307          * Function Name: USB_LoadInEP
1308          ****************************************************************************//**
1309          *
1310          *  This function performs different functionality depending on the Component’s
1311          *  configured Endpoint Buffer Management. This parameter is defined in
1312          *  the Descriptor Root in Component Configure window.
1313          *
1314          *  *Manual (Static/Dynamic Allocation):*
1315          *  This function loads and enables the specified USB data endpoint for an IN
1316          *  data transfer.
1317          *
1318          *  *DMA with Manual Buffer Management:*
1319          *  Configures DMA for a data transfer from system RAM to endpoint buffer.
1320          *  Generates request for a transfer.
1321          *
1322          *  *DMA with Automatic Buffer Management:*
1323          *  Configures DMA. This is required only once, so it is done only when parameter
1324          *  pData is not NULL. When the pData pointer is NULL, the function skips this
1325          *  task. Sets Data ready status: This generates the first DMA transfer and
1326          *  prepares data in endpoint buffer.
1327          *
1328          *  \param epNumber Contains the data endpoint number.
1329          *            Valid values are between 1 and 8.
1330          *  \param *pData A pointer to a data array from which the data for the endpoint space
1331          *          is loaded.
1332          *  \param length The number of bytes to transfer from the array and then send as
1333          *          a result of an IN request. Valid values are between 0 and 512
1334          *          (1023 for DMA with Automatic Buffer Management mode). The value 512
1335          *          is applicable if only one endpoint is used.
1336          *
1337          *
1338          * \reentrant
1339          *  No.
1340          *
1341          *******************************************************************************/
1342          void USB_LoadInEP(uint8 epNumber, const uint8 pData[], uint16 length)
1343                                                                                  CYREENTRANT
1344          {
1345   1          if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 23  

1346   1          {
1347   2          #if (!USB_EP_MANAGEMENT_DMA_AUTO)
1348   2              /* Limit length to available buffer USB IP buffer size.*/
1349   2              if (length > (USB_EPX_DATA_BUF_MAX - USB_EP[epNumber].buffOffset))
1350   2              {
1351   3                  length = USB_EPX_DATA_BUF_MAX - USB_EP[epNumber].buffOffset;
1352   3              }
1353   2          #endif /* (!USB_EP_MANAGEMENT_DMA_AUTO) */
1354   2      
1355   2              /* Set count and data toggle. */
1356   2              USB_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint8) HI8(length) | USB_EP[epNumber].epToggle;
1357   2              USB_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint8) LO8(length);
1358   2      
1359   2          #if (USB_EP_MANAGEMENT_MANUAL)
1360   2              if (NULL != pData)
1361   2              {
1362   3                              /* Copy data using arbiter data register. */
1363   3                  uint16 i;
1364   3                  for (i = 0u; i < length; ++i)
1365   3                  {
1366   4                      USB_ARB_EP_BASE.arbEp[epNumber].rwDr = pData[i];
1367   4                  }
1368   3              }
1369   2      
1370   2              /* IN endpoint buffer is full - read to be read. */
1371   2              USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
1372   2      
1373   2              /* Arm IN endpoint. */
1374   2              USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
1375   2      
1376   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USB_DmaTd[epNumber])
                          {
                              USB_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USB_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USB_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) pData);
                              USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP_BASE.arbEp[epNumber
             -].rwDr);
              
                              /* Configure DMA descriptor. */
                              --length;
                              USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG | length |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 24  

              
                              /* Validate descriptor to execute on following DMA request. */
                              USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USB_CyDmaChEnable(channelNum);
                          #else
                              /* Configure DMA to transfer data. */
                              (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                              (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERMIN_E
             -N | TD_INC_SRC_ADR);
                              (void) CyDmaTdSetAddress(USB_DmaTd[epNumber], LO16((uint32) pData), LO16((uint32) &USB_ARB
             -_EP_BASE.arbEp[epNumber].rwDr));
              
                              /* Enable DMA channel. */
                              (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
              
                              /* Generate DMA request. */
                              USB_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USB_ARB_EPX_CFG_DMA_REQ;
                              USB_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USB_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
                          }
                      #endif /* (USB_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USB_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                          #if (CY_PSOC4)
                              uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USB_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USB_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP_BASE.arbEp[epNumber
             -].rwDr);
                              USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR1, (void*) &USB_ARB_EP_BASE.arbEp[epNumber
             -].rwDr);
              
                              /* Configure DMA descriptor. */
                              USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR1, USB_DMA_COMMON_CFG  |
                                                                      CYDMA_BYTE | CYDMA_ELEMENT_WORD | CYDMA_INC_SRC_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 25  

                              USB_CyDmaSetInterruptMask(channelNum);
              
              
                              /* Enable DMA channel: configuration complete. */
                              USB_CyDmaChEnable(channelNum);
              
                          #else
                              (void) CyDmaChDisable(USB_DmaChan[epNumber]);
              
                              #if (USB_EP_DMA_AUTO_OPT == 0u)
                                  USB_inLength[epNumber] = length;
                                  USB_inDataPointer[epNumber] = pData;
              
                                  /* Configure DMA to send data only for first burst */
                                  (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber],
                                      (length > USB_DMA_BYTES_PER_BURST) ? USB_DMA_BYTES_PER_BURST : length,
                                      USB_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                                  (void) CyDmaTdSetAddress(USB_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USB_ARB_EP_B
             -ASE.arbEp[epNumber].rwDr));
              
                                  /* The second TD will be executed only when the first one fails.
                                  *  The intention of this TD is to generate NRQ interrupt
                                  *  and repeat 2 last bytes of the first burst.
                                  */
                                  (void) CyDmaTdSetConfiguration(USB_DmaNextTd[epNumber], 1u,
                                                                 USB_DmaNextTd[epNumber],
                                                                 USB_epX_TD_TERMOUT_EN[epNumber]);
              
                                  /* Configure DmaNextTd to clear Data Ready status. */
                                  (void) CyDmaTdSetAddress(USB_DmaNextTd[epNumber], LO16((uint32) &clearInDataRdyStatus)
             -,
                                                                                                 LO16((uint32) &USB_ARB_
             -EP_BASE.arbEp[epNumber].epCfg));
                              #else
                                  /* Configure DMA to send all data. */
                                  (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length,
                                                                 USB_DmaTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR);
                                  (void) CyDmaTdSetAddress(USB_DmaTd[epNumber], LO16((uint32) pData),
                                                                                             LO16((uint32) &USB_ARB_EP_B
             -ASE.arbEp[epNumber].rwDr));
                              #endif /* (USB_EP_DMA_AUTO_OPT == 0u) */
              
                              /* Clear any potential pending DMA requests before starting DMA channel to transfer data. 
             -*/
                              (void) CyDmaClearPendingDrq(USB_DmaChan[epNumber]);
                              /* Enable DMA. */
                              (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                              (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                          #endif /* (CY_PSOC4) */
                          }
                          else
                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                              #if (CY_PSOC4)
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 26  

                                  /* Get number of full bursts. */
                                  USB_DmaEpBurstCnt[epNumber] = (uint8) (length / USB_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USB_DmaEpLastBurstEl[epNumber] = (uint8) (length % USB_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USB_DmaEpBurstCnt[epNumber] += (0u != USB_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USB_DmaEpLastBurstEl[epNumber] = (0u != USB_DmaEpLastBurstEl[epNumber]) ?
                                                                                        (USB_DmaEpLastBurstEl[epNumber] 
             -- 1u) :
                                                                                        (USB_DMA_BYTES_PER_BURST - 1u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : 
             -(USB_DMA_BYTES_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : 
             -(USB_DMA_BYTES_PER_BURST - 1u);
              
              
                                  /* Mark which descriptor is last one to execute. */
                                  USB_DmaEpLastBurstEl[epNumber] |= (0u != (USB_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                          USB_DMA_DESCR0_MASK : USB_DMA_
             -DESCR1_MASK;
              
                                  /* Restore DMA settings for current transfer. */
                                  USB_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) ((uint32) USB_DmaEpBufferAd
             -drBackup[epNumber]));
                                  USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR1, (void*) ((uint32) USB_DmaEpBufferAd
             -drBackup[epNumber] +
                                                                                                                        
             -         USB_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USB_CyDmaSetNumDataElements(channelNum, USB_DMA_DESCR0, lengthDescr0);
                                  USB_CyDmaSetNumDataElements(channelNum, USB_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
                                  USB_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Validate descriptor 1. */
                                  if (USB_DmaEpBurstCnt[epNumber] > 1u)
                                  {
                                      USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR1); 
                                  }                   
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
             -fter valid descriptor were executed. */
                                  USB_DmaEpBurstCnt[epNumber] = USB_DMA_GET_BURST_CNT(USB_DmaEpBurstCnt[epNumber]);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USB_CyDmaChEnable(channelNum);
              
                              #elif (USB_EP_DMA_AUTO_OPT == 0u)
                                  USB_inLength[epNumber]  = length;
                                  USB_inBufFull[epNumber] = 0u;
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 27  

              
                                  (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                                  /* Configure DMA to send data only for first burst. */
                                  (void) CyDmaTdSetConfiguration(
                                      USB_DmaTd[epNumber], (length > USB_DMA_BYTES_PER_BURST) ?
                                      USB_DMA_BYTES_PER_BURST : length,
                                      USB_DmaNextTd[epNumber], TD_TERMIN_EN | TD_INC_SRC_ADR );
                                  (void) CyDmaTdSetAddress(USB_DmaTd[epNumber], LO16((uint32)  USB_inDataPointer[epNumbe
             -r]),
                                                                                             LO16((uint32) &USB_ARB_EP_B
             -ASE.arbEp[epNumber].rwDr));
                                  /* Clear Any potential pending DMA requests before starting DMA channel to transfer da
             -ta. */
                                  (void) CyDmaClearPendingDrq(USB_DmaChan[epNumber]);
                                  /* Enable DMA. */
                                  (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                                  (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                              #endif /* (CY_PSOC4) */
              
                              #if !defined (USB_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USB_ARB_EP_BASE.arbEp[epNumber].epCfg |= USB_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USB_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USB_EP_MANAGEMENT_MANUAL) */
1603   2          }
1604   1      }
1605          
1606          
1607          /*******************************************************************************
1608          * Function Name: USB_ReadOutEP
1609          ****************************************************************************//**
1610          *
1611          *   This function performs different functionality depending on the Component’s
1612          *   configured Endpoint Buffer Management. This parameter is defined in the
1613          *   Descriptor Root in Component Configure window.
1614          *
1615          *   *Manual (Static/Dynamic Allocation):*
1616          *   This function moves the specified number of bytes from endpoint buffer to
1617          *   system RAM. The number of bytes actually transferred from endpoint buffer to
1618          *   system RAM is the lesser of the actual number of bytes sent by the host or
1619          *   the number of bytes requested by the length parameter.
1620          *
1621          *   *DMA with Manual Buffer Management:*
1622          *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
1623          *   a DMA request. The firmware must wait until the DMA completes the data
1624          *   transfer after calling the USB_ReadOutEP() API. For example,
1625          *   by checking EPstate:
1626          *
1627          *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
1628          *
1629          *   The USBFS_EnableOutEP() has to be called to allow host to write data into
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 28  

1630          *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
1631          *   buffer to SRAM.
1632          *
1633          *   *DMA with Automatic Buffer Management:*
1634          *   Configure DMA. This is required only once and automatically generates DMA
1635          *   requests as data arrives
1636          *
1637          *  \param epNumber: Contains the data endpoint number.
1638          *            Valid values are between 1 and 8.
1639          *  \param pData: A pointer to a data array from which the data for the endpoint
1640          *         space is loaded.
1641          *  \param length: The number of bytes to transfer from the USB Out endpoint and
1642          *          loads it into data array. Valid values are between 0 and 1023. The
1643          *          function moves fewer than the requested number of bytes if the host
1644          *          sends fewer bytes than requested.
1645          *
1646          * \return
1647          *  Number of bytes received, 0 for an invalid endpoint.
1648          *
1649          * \reentrant
1650          *  No.
1651          *
1652          *******************************************************************************/
1653          uint16 USB_ReadOutEP(uint8 epNumber, uint8 pData[], uint16 length)
1654                                                                                  CYREENTRANT
1655          {
1656   1          if ((pData != NULL) && (epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
1657   1          {
1658   2          #if (!USB_EP_MANAGEMENT_DMA_AUTO)
1659   2              /* Adjust requested length to available data. */
1660   2              length = (length > USB_GetEPCount(epNumber)) ? USB_GetEPCount(epNumber) : length;
1661   2          #endif /* (!USB_EP_MANAGEMENT_DMA_AUTO) */
1662   2      
1663   2          #if (USB_EP_MANAGEMENT_MANUAL)
1664   2              {
1665   3                  /* Copy data using arbiter data register. */
1666   3                  uint16 i;
1667   3                  for (i = 0u; i < length; ++i)
1668   3                  {
1669   4                      pData[i] = (uint8) USB_ARB_EP_BASE.arbEp[epNumber].rwDr;
1670   4                  }
1671   3              }
1672   2      
1673   2              /* Arm OUT endpoint after data has been copied from endpoint buffer. */
1674   2              USB_EnableOutEP(epNumber);
1675   2          #else
              
                      #if (CY_PSOC3 || CY_PSOC5LP)
                          /* Initialize DMA if it was not initialized. */
                          if (DMA_INVALID_TD == USB_DmaTd[epNumber])
                          {
                              USB_InitEP_DMA(epNumber, pData);
                          }
                      #endif /* (CY_PSOC3 || CY_PSOC5LP) */
              
                      #if (USB_EP_MANAGEMENT_DMA_MANUAL)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USB_CyDmaChDisable(channelNum);
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 29  

              
                          /* Configure source and destination. */
                          USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP_BASE.arbEp[epNumber].rw
             -Dr);
                          USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG | (uint16)(length - 1
             -u) |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USB_CyDmaChEnable(channelNum);
                      }
                      #else
                          /* Configure DMA to transfer data. */
                          (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length, CY_DMA_DISABLE_TD, TD_TERMIN_EN | 
             -TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USB_DmaTd[epNumber], LO16((uint32) &USB_ARB_EP_BASE.arbEp[epNumber].r
             -wDr), LO16((uint32)pData));
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* Generate DMA request. */
                          USB_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint8)  USB_ARB_EPX_CFG_DMA_REQ;
                          USB_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint8) ~USB_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USB_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USB_EP_MANAGEMENT_DMA_AUTO)
                      #if (CY_PSOC4)
                      {
                          uint32 channelNum = (uint32) USB_DmaChan[epNumber];
                          uint32 lengthDescr0, lengthDescr1;
              
                          /* Get number of full bursts. */
                          USB_DmaEpBurstCnt[epNumber] = (uint8) (length / USB_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in the last burst. */
                          USB_DmaEpLastBurstEl[epNumber] = (uint8) (length % USB_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USB_DmaEpBurstCnt[epNumber] += (0u != USB_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of the data elements transfered in last burst. */
                          USB_DmaEpLastBurstEl[epNumber] = (0u != USB_DmaEpLastBurstEl[epNumber]) ?
                                                                                (USB_DmaEpLastBurstEl[epNumber] - 1u) :
                                                                                (USB_DMA_BYTES_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 30  

                          lengthDescr0 = (1u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : (USB_DMA
             -_BYTES_PER_BURST - 1u);
                          lengthDescr1 = (2u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : (USB_DMA
             -_BYTES_PER_BURST - 1u);
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USB_DmaEpLastBurstEl[epNumber] |= (USB_DmaEpBurstCnt[epNumber] > 2u) ? USB_DMA_DESCR_REVERT : 
             -0u;
              
                          /* Mark last descriptor to be executed. */
                          USB_DmaEpLastBurstEl[epNumber] |= (0u != (USB_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USB_DMA_DESCR0_MASK : USB_DMA_DESCR1_M
             -ASK;
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USB_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USB_DmaEpBurstCntBackup[epNumber]   = USB_DmaEpBurstCnt[epNumber];
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
                          USB_DmaEpBurstCnt[epNumber] = USB_DMA_GET_BURST_CNT(USB_DmaEpBurstCnt[epNumber]);
              
                          /* Disable DMA channel: start configuration. */
                          USB_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP_BASE.arbEp[epNumber].rw
             -Dr);
                          USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR1, (void*) &USB_ARB_EP_BASE.arbEp[epNumber].rw
             -Dr);
              
                          USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) ((uint32) pData));
                          USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR1, (void*) ((uint32) pData + USB_DMA_BYTES_PER
             -_BURST));
              
                          /* Configure DMA descriptor. */
                          USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG  | lengthDescr0 |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor. */
                          USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR1, USB_DMA_COMMON_CFG  | lengthDescr1 |
                                                                  CYDMA_BYTE | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_ADDR |
             - CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USB_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
              
                          if (USB_DmaEpBurstCntBackup[epNumber] > 1u)
                          {
                              USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR1);
                          }
              
                          /* Enable DMA channel: configuration complete. */
                          USB_CyDmaChEnable(channelNum);
                      }
                      #else
                          (void) CyDmaChDisable(USB_DmaChan[epNumber]);
                          (void) CyDmaTdSetConfiguration(USB_DmaTd[epNumber], length,  USB_DmaTd[epNumber], TD_TERMIN_EN
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 31  

             - | TD_INC_DST_ADR);
                          (void) CyDmaTdSetAddress(USB_DmaTd[epNumber], LO16((uint32) &USB_ARB_EP_BASE.arbEp[epNumber].r
             -wDr), LO16((uint32) pData));
              
                          /* Clear Any potential pending DMA requests before starting DMA channel to transfer data. */
                          (void) CyDmaClearPendingDrq(USB_DmaChan[epNumber]);
              
                          /* Enable DMA channel. */
                          (void) CyDmaChSetInitialTd(USB_DmaChan[epNumber], USB_DmaTd[epNumber]);
                          (void) CyDmaChEnable(USB_DmaChan[epNumber], 1u);
                      #endif /* (CY_PSOC4) */
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
              
                      #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USB_EP_MANAGEMENT_MANUAL) */
1817   2          }
1818   1          else
1819   1          {
1820   2              length = 0u;
1821   2          }
1822   1      
1823   1          return (length);
1824   1      }
1825          
1826          
1827          #if (USB_16BITS_EP_ACCESS_ENABLE)
              /*******************************************************************************
              * Function Name: USB_LoadInEP16
              ****************************************************************************//**
              *
              *  This function performs different functionality depending on the Component’s
              *  configured Endpoint Buffer Management. This parameter is defined in
              *  the Descriptor Root in Component Configure window.
              *
              *  *Manual (Static/Dynamic Allocation):*
              *  This function loads and enables the specified USB data endpoint for an IN
              *  data transfer.
              *
              *  *DMA with Manual Buffer Management:*
              *  Configures DMA for a data transfer from system RAM to endpoint buffer.
              *  Generates request for a transfer.
              *
              *  *DMA with Automatic Buffer Management:*
              *  Configures DMA. This is required only once, so it is done only when parameter
              *  pData is not NULL. When the pData pointer is NULL, the function skips this
              *  task. Sets Data ready status: This generates the first DMA transfer and
              *  prepares data in endpoint buffer.
              *
              *  \param epNumber Contains the data endpoint number.
              *        Valid values are between 1 and 8.
              *  \param *pData A pointer to a data array from which the data for the endpoint
              *        space is loaded. It shall be ensured that this pointer address is even
              *        to ensure the 16-bit transfer is aligned to even address. Else, a hard
              *        fault condition can occur.
              *  \param length The number of bytes to transfer from the array and then send as
              *        a result of an IN request. Valid values are between 0 and 512 (1023 for
              *        DMA with Automatic Buffer Management mode). The value 512 is applicable
              *        if only one endpoint is used.
              *
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 32  

              * \reentrant
              *  No.
              *
              *******************************************************************************/
              void USB_LoadInEP16(uint8 epNumber, const uint8 pData[], uint16 length)
              {
                  /* Check array alignment on half-word boundary. */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
                  {
                  #if (!USB_EP_MANAGEMENT_DMA_AUTO)
                      /* Limit length to available buffer USB IP buffer size. */
                      if (length > (USB_EPX_DATA_BUF_MAX - USB_EP[epNumber].buffOffset))
                      {
                          length = USB_EPX_DATA_BUF_MAX - USB_EP[epNumber].buffOffset;
                      }
                  #endif /* (!USB_EP_MANAGEMENT_DMA_AUTO) */
              
                      /* Set count and data toggle. */
                      USB_SIE_EP_BASE.sieEp[epNumber].epCnt0 = (uint32) HI8(length) | USB_EP[epNumber].epToggle;
                      USB_SIE_EP_BASE.sieEp[epNumber].epCnt1 = (uint32) LO8(length);
              
                      /* Adjust requested length: 2 bytes are handled at one data register access. */
                      length += (length & 0x01u);
              
                  #if (USB_EP_MANAGEMENT_MANUAL)
                      if (NULL != pData)
                      {
                          /* Convert uint8 array to uint16. */
                          const uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (length >> 1u); ++i)
                          {
                              USB_ARB_EP16_BASE.arbEp[epNumber].rwDr16 = dataBuf[i];
                          }
                      }
              
                      /* IN endpoint buffer is full - read to be read. */
                      USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
              
                      /* Arm IN endpoint. */
                      USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
              
                  #else
              
                      #if (USB_EP_MANAGEMENT_DMA_MANUAL)
                          /* IN endpoint buffer will be fully loaded by DMA shortly. */
                          USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
              
                          if ((pData != NULL) && (length > 0u))
                          {
                              uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                              /* Disable DMA channel: start configuration. */
                              USB_CyDmaChDisable(channelNum);
              
                              /* Configure source and destination. */
                              USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) pData);
                              USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP16_BASE.arbEp[epNumb
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 33  

             -er].rwDr16);
              
                              /* Configure DMA descriptor. */
                              length = (length >> 1u) - 1u;
                              USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG | length |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                              /* Validate descriptor to execute on following DMA request. */
                              USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
              
                              /* Enable DMA channel: configuration complete. */
                              USB_CyDmaChEnable(channelNum);
              
                              /* Generate DMA request. */
                              USB_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USB_ARB_EPX_CFG_DMA_REQ;
                              USB_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USB_ARB_EPX_CFG_DMA_REQ;
              
                              /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer has 
             -been completed. */
                          }
                          else
                          {
                              /* When zero-length packet: arm IN endpoint directly. */
                              USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
                          }
                      #endif /* (USB_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USB_EP_MANAGEMENT_DMA_AUTO)
                          if (pData != NULL)
                          {
                              uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                              /* Store address of buffer. */
                              USB_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
              
                              /* Disable DMA channel: start configuration. */
                              USB_CyDmaChDisable(channelNum);
              
                              /* Set destination address. */
                              USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP16_BASE.arbEp[epNumb
             -er].rwDr16);
                              USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR1, (void*) &USB_ARB_EP16_BASE.arbEp[epNumb
             -er].rwDr16);
              
                              /* Configure DMA descriptor. */
                              USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Configure DMA descriptor. */
                              USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR1, USB_DMA_COMMON_CFG  |
                                                                      CYDMA_HALFWORD | CYDMA_ELEMENT_WORD | CYDMA_INC_SR
             -C_ADDR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                              /* Enable interrupt from DMA channel. */
                              USB_CyDmaSetInterruptMask(channelNum);
              
                              /* Enable DMA channel: configuration complete. */
                              USB_CyDmaChEnable(channelNum);
                          }
                          else
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 34  

                          {
                              /* IN endpoint buffer (32 bytes) will shortly be preloaded by DMA. */
                              USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
              
                              if (length > 0u)
                              {
                                  uint32 lengthDescr0, lengthDescr1;
                                  uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                                  /* Get number of full bursts. */
                                  USB_DmaEpBurstCnt[epNumber] = (uint8) (length / USB_DMA_BYTES_PER_BURST);
              
                                  /* Get number of elements in the last burst. */
                                  USB_DmaEpLastBurstEl[epNumber] = (uint8) (length % USB_DMA_BYTES_PER_BURST);
              
                                  /* Get total number of bursts. */
                                  USB_DmaEpBurstCnt[epNumber] += (0u != USB_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                                  /* Adjust number of data elements transferred in last burst. */
                                  USB_DmaEpLastBurstEl[epNumber] = (0u != USB_DmaEpLastBurstEl[epNumber]) ?
                                                                                        ((USB_DmaEpLastBurstEl[epNumber]
             - >> 1u) - 1u) :
                                                                                         (USB_DMA_HALFWORDS_PER_BURST - 
             -1u);
              
                                  /* Get number of data elements to transfer for descriptor 0 and 1. */
                                  lengthDescr0 = (1u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : 
             -(USB_DMA_HALFWORDS_PER_BURST - 1u);
                                  lengthDescr1 = (2u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : 
             -(USB_DMA_HALFWORDS_PER_BURST - 1u);
              
                                  /* Mark which descriptor is last one to execute. */
                                  USB_DmaEpLastBurstEl[epNumber] |= (0u != (USB_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                          USB_DMA_DESCR0_MASK : USB_DMA_
             -DESCR1_MASK;
              
                                  /* Restore DMA settings for current transfer. */
                                  USB_CyDmaChDisable(channelNum);
              
                                  /* Restore destination address for input endpoint. */
                                  USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) ((uint32) USB_DmaEpBufferAd
             -drBackup[epNumber]));
                                  USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR1, (void*) ((uint32) USB_DmaEpBufferAd
             -drBackup[epNumber] +
                                                                                                                        
             -         USB_DMA_BYTES_PER_BURST));
              
                                  /* Set number of elements to transfer. */
                                  USB_CyDmaSetNumDataElements(channelNum, USB_DMA_DESCR0, lengthDescr0);
                                  USB_CyDmaSetNumDataElements(channelNum, USB_DMA_DESCR1, lengthDescr1);
              
                                  /* Validate descriptor 0 and command to start with it. */
                                  USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
                                  USB_CyDmaSetDescriptor0Next(channelNum);
              
                                  /* Validate descriptor 1. */
                                  if (USB_DmaEpBurstCnt[epNumber] > 1u)
                                  {
                                      USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR1);
                                  }
              
                                  /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger a
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 35  

             -fter valid descriptor were executed. */
                                  USB_DmaEpBurstCnt[epNumber] = USB_DMA_GET_BURST_CNT(USB_DmaEpBurstCnt[epNumber]);
              
                                  /* Enable DMA channel: configuration complete. */
                                  USB_CyDmaChEnable(channelNum);
              
                              #if !defined (USB_MANUAL_IN_EP_ARM)
                                  /* Set IN data ready to generate DMA request to load data into endpoint buffer. */
                                  USB_ARB_EP_BASE.arbEp[epNumber].epCfg |= USB_ARB_EPX_CFG_IN_DATA_RDY;
                              #endif  /* (USB_MANUAL_IN_EP_ARM) */
              
                                  /* IN endpoint will be armed in ARB_ISR(source: IN_BUF_FULL) after first DMA transfer 
             -has been completed. */
                              }
                              else
                              {
                                  /* When zero-length packet: arm IN endpoint directly. */
                                  USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
                              }
                          }
                      #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USB_EP_MANAGEMENT_MANUAL) */
                  }
              }
              
              
              /*******************************************************************************
              * Function Name: USB_ReadOutEP16
              ****************************************************************************//**
              *
              *   This function performs different functionality depending on the Component’s
              *   configured Endpoint Buffer Management. This parameter is defined in the
              *   Descriptor Root in Component Configure window.
              *
              *   *Manual (Static/Dynamic Allocation):*
              *   This function moves the specified number of bytes from endpoint buffer to
              *   system RAM. The number of bytes actually transferred from endpoint buffer to
              *   system RAM is the lesser of the actual number of bytes sent by the host or
              *   the number of bytes requested by the length parameter.
              *
              *   *DMA with Manual Buffer Management:*
              *   Configure DMA to transfer data from endpoint buffer to system RAM. Generate
              *   a DMA request. The firmware must wait until the DMA completes the data
              *   transfer after calling the USB_ReadOutEP() API. For example,
              *   by checking EPstate:
              *
              *   \snippet /USBFS_sut_02.cydsn/main.c checking EPstatey
              *
              *   The USBFS_EnableOutEP() has to be called to allow host to write data into
              *   the endpoint buffer after DMA has completed transfer data from OUT endpoint
              *   buffer to SRAM.
              *
              *   *DMA with Automatic Buffer Management:*
              *   Configure DMA. This is required only once and automatically generates DMA
              *   requests as data arrives
              *
              *  \param epNumber: Contains the data endpoint number.
              *         Valid values are between 1 and 8.
              *  \param pData: A pointer to a data array into which the data for the endpoint
              *         space is copied. It shall be ensured that this pointer address is
              *         even to ensure the 16-bit transfer is aligned to even address. Else,
              *         a hard fault condition can occur.
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 36  

              *  \param length: The number of bytes to transfer from the USB Out endpoint and
              *         loads it into data array. Valid values are between 0 and 1023. The
              *         function moves fewer than the requested number of bytes if the host
              *         sends fewer bytes than requested.
              *
              * \return
              *  Number of bytes received, 0 for an invalid endpoint.
              *
              * \reentrant
              *  No.
              *
              *******************************************************************************/
              uint16 USB_ReadOutEP16(uint8 epNumber, uint8 pData[], uint16 length)
              {
                  uint32 adjLength;
              
                  /* Check array alignment on half-word boundary */
                  CYASSERT(0u == (((uint32) pData) & 0x01u));
              
                  if ((pData != NULL) && (epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
                  {
                  #if (!USB_EP_MANAGEMENT_DMA_AUTO)
                      /* Adjust requested length to available data. */
                      length = (length > USB_GetEPCount(epNumber)) ? USB_GetEPCount(epNumber) : length;
                  #endif /* (!USB_EP_MANAGEMENT_DMA_AUTO) */
              
                  /* Adjust requested length: 2 bytes are handled at one data register access. */
                  adjLength =  length + ((uint32)length & 1u);
              
                  #if (USB_EP_MANAGEMENT_MANUAL)
                      {
                          /* Convert uint8 array to uint16. */
                          uint16 *dataBuf = (uint16 *) pData;
              
                          /* Copy data using 16-bits arbiter data register. */
                          uint16 i;
                          for (i = 0u; i < (adjLength >> 1u); ++i)
                          {
                              dataBuf[i] = (uint16) USB_ARB_EP16_BASE.arbEp[epNumber].rwDr16;
                          }
                      }
              
                      /* Arm OUT endpoint after data has been read from endpoint buffer. */
                      USB_EnableOutEP(epNumber);
                  #else
              
                      #if (USB_EP_MANAGEMENT_DMA_MANUAL)
                      {
                          uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                          /* Disable DMA channel: start configuration. */
                          USB_CyDmaChDisable(channelNum);
              
                          /* Configure source and destination. */
                          USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP16_BASE.arbEp[epNumber].
             -rwDr16);
                          USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) pData);
              
                          /* Configure DMA descriptor. */
                          USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG | (uint16)((adjLength
             - >> 1u) - 1u) |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 37  

             -DR | CYDMA_INVALIDATE | CYDMA_PREEMPTABLE);
              
                          /* Validate descriptor to execute on following DMA request. */
                          USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
              
                          /* Enable DMA channel: configuration complete. */
                          USB_CyDmaChEnable(channelNum);
              
                          /* Generate DMA request. */
                          USB_ARB_EP_BASE.arbEp[epNumber].epCfg |=  (uint32)  USB_ARB_EPX_CFG_DMA_REQ;
                          USB_ARB_EP_BASE.arbEp[epNumber].epCfg &=  (uint32) ~USB_ARB_EPX_CFG_DMA_REQ;
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USB_EP_MANAGEMENT_DMA_MANUAL) */
              
                      #if (USB_EP_MANAGEMENT_DMA_AUTO)
                      {
                          uint32 lengthDescr0, lengthDescr1;
                          uint32 channelNum = (uint32) USB_DmaChan[epNumber];
              
                          /* Get number of full bursts. */
                          USB_DmaEpBurstCnt[epNumber] = (uint8) (adjLength / USB_DMA_BYTES_PER_BURST);
              
                          /* Get number of elements in last burst. */
                          USB_DmaEpLastBurstEl[epNumber] = (uint8) (adjLength % USB_DMA_BYTES_PER_BURST);
              
                          /* Get total number of bursts. */
                          USB_DmaEpBurstCnt[epNumber] += (0u != USB_DmaEpLastBurstEl[epNumber]) ? 1u : 0u;
              
                          /* Adjust number of data elements transferred in last burst. */
                          USB_DmaEpLastBurstEl[epNumber] = (0u != USB_DmaEpLastBurstEl[epNumber]) ?
                                                                                ((USB_DmaEpLastBurstEl[epNumber] >> 1u) 
             -- 1u) :
                                                                                 (USB_DMA_HALFWORDS_PER_BURST - 1u);
              
                          /* Get number of data elements to transfer for descriptor 0 and 1. */
                          lengthDescr0 = (1u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : (USB_DMA
             -_HALFWORDS_PER_BURST - 1u);
                          lengthDescr1 = (2u == USB_DmaEpBurstCnt[epNumber]) ? USB_DmaEpLastBurstEl[epNumber] : (USB_DMA
             -_HALFWORDS_PER_BURST - 1u);
              
                          /* Mark last descriptor to be executed. */
                          USB_DmaEpLastBurstEl[epNumber] |= (0u != (USB_DmaEpBurstCnt[epNumber] & 0x1u)) ?
                                                                                  USB_DMA_DESCR0_MASK : USB_DMA_DESCR1_M
             -ASK;
              
                          /* Mark if revert number of data elements in descriptor after transfer completion. */
                          USB_DmaEpLastBurstEl[epNumber] |= (USB_DmaEpBurstCnt[epNumber] > 2u) ? USB_DMA_DESCR_REVERT : 
             -0u;
              
                          /* Mark that 16-bits access to data register is performed. */
                          USB_DmaEpLastBurstEl[epNumber] |= USB_DMA_DESCR_16BITS;
              
                          /* Store address of buffer and burst counter for endpoint. */
                          USB_DmaEpBufferAddrBackup[epNumber] = (uint32) pData;
                          USB_DmaEpBurstCntBackup[epNumber]   = USB_DmaEpBurstCnt[epNumber];
              
                          /* Adjust burst counter taking to account: 2 valid descriptors and interrupt trigger after val
             -id descriptor were executed. */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 38  

                          USB_DmaEpBurstCnt[epNumber] = USB_DMA_GET_BURST_CNT(USB_DmaEpBurstCnt[epNumber]);
              
                          /* Disable DMA channel: start configuration. */
                          USB_CyDmaChDisable(channelNum);
              
                          /* Set destination address. */
                          USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR0, (void*) &USB_ARB_EP16_BASE.arbEp[epNumber].
             -rwDr16);
                          USB_CyDmaSetSrcAddress(channelNum, USB_DMA_DESCR1, (void*) &USB_ARB_EP16_BASE.arbEp[epNumber].
             -rwDr16);
              
                          USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR0, (void*) ((uint32) pData));
                          USB_CyDmaSetDstAddress(channelNum, USB_DMA_DESCR1, (void*) ((uint32) pData + USB_DMA_BYTES_PER
             -_BURST));
              
                          /* Configure DMA descriptor 0. */
                          USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR0, USB_DMA_COMMON_CFG  | lengthDescr0 |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Configure DMA descriptor 1. */
                          USB_CyDmaSetConfiguration(channelNum, USB_DMA_DESCR1, USB_DMA_COMMON_CFG  | lengthDescr1 |
                                                                  CYDMA_HALFWORD | CYDMA_WORD_ELEMENT | CYDMA_INC_DST_AD
             -DR | CYDMA_INVALIDATE | CYDMA_CHAIN);
              
                          /* Enable interrupt from DMA channel. */
                          USB_CyDmaSetInterruptMask(channelNum);
              
                          /* Validate DMA descriptor 0 and 1. */
                          USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR0);
                          
                          if (USB_DmaEpBurstCntBackup[epNumber] > 1u)
                          {
                              USB_CyDmaValidateDescriptor(channelNum, USB_DMA_DESCR1);
                          }
              
                          /* Enable DMA channel: configuration complete. */
                          USB_CyDmaChEnable(channelNum);
              
                          /* OUT endpoint has to be armed again by user when DMA transfers have been completed.
                          * NO_EVENT_PENDING: notifies that data has been copied from endpoint buffer.
                          */
                      }
                      #endif /* (USB_EP_MANAGEMENT_DMA_AUTO) */
                  #endif /* (USB_EP_MANAGEMENT_MANUAL) */
                  }
                  else
                  {
                      length = 0u;
                  }
              
                  return (length);
              }
              #endif /* (USB_16BITS_EP_ACCESS_ENABLE) */
2256          
2257          
2258          /*******************************************************************************
2259          * Function Name: USB_EnableOutEP
2260          ****************************************************************************//**
2261          *
2262          *  This function enables the specified endpoint for OUT transfers. Do not call
2263          *  this function for IN endpoints.
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 39  

2264          *
2265          *  \param epNumber: Contains the data endpoint number. Valid values are between
2266          *  1 and 8.
2267          *
2268          * \globalvars
2269          *
2270          *  \ref USB_EP[epNumber].apiEpState - set to NO_EVENT_PENDING
2271          *
2272          * \reentrant
2273          *  No.
2274          *
2275          *******************************************************************************/
2276          void USB_EnableOutEP(uint8 epNumber) CYREENTRANT
2277          {
2278   1          if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
2279   1          {
2280   2              USB_EP[epNumber].apiEpState = USB_NO_EVENT_PENDING;
2281   2      
2282   2              /* Enable OUT endpoint to be written by Host. */
2283   2              USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_EP[epNumber].epMode;
2284   2              
2285   2          }
2286   1      }
2287          
2288          
2289          /*******************************************************************************
2290          * Function Name: USB_DisableOutEP
2291          ****************************************************************************//**
2292          *
2293          *  This function disables the specified USBFS OUT endpoint. Do not call this
2294          *  function for IN endpoints.
2295          *
2296          *  \param epNumber: Contains the data endpoint number.
2297          *            Valid values are between 1 and 8.
2298          *
2299          *******************************************************************************/
2300          void USB_DisableOutEP(uint8 epNumber) 
2301          {
2302   1          if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
2303   1          {
2304   2              /* Set NAK response for OUT endpoint. */
2305   2              USB_SIE_EP_BASE.sieEp[epNumber].epCr0 = USB_MODE_NAK_OUT;
2306   2          }
2307   1      }
2308          
2309          
2310          /*******************************************************************************
2311          * Function Name: USB_Force
2312          ****************************************************************************//**
2313          *
2314          *  This function forces a USB J, K, or SE0 state on the D+/D– lines. It provides
2315          *  the necessary mechanism for a USB device application to perform a USB Remote
2316          *  Wakeup. For more information, see the USB 2.0 Specification for details on
2317          *  Suspend and Resume.
2318          *
2319          *  \param state A byte indicating which of the four bus states to enable.
2320          *        Symbolic names  and their associated values are listed here:
2321          *    State                      |Description
2322          *    ---------------------------|----------------------------------------------
2323          *    USB_FORCE_J   | Force a J State onto the D+/D– lines
2324          *    USB_FORCE_K   | Force a K State onto the D+/D– lines
2325          *    USB_FORCE_SE0 | Force a Single Ended 0 onto the D+/D– lines
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 40  

2326          *    USB_FORCE_NONE| Return bus to SIE control
2327          *
2328          *
2329          *******************************************************************************/
2330          void USB_Force(uint8 bState) 
2331          {
2332   1          /* This registers is used only for manual control of SIE (no masking is
2333   1          * needed before write into it).
2334   1          */
2335   1          USB_USBIO_CR0_REG = bState;
2336   1      }
2337          
2338          
2339          /*******************************************************************************
2340          * Function Name: USB_GetEPAckState
2341          ****************************************************************************//**
2342          *
2343          *  This function determines whether an ACK transaction occurred on this endpoint
2344          *  by reading the ACK bit in the control register of the endpoint. It does not
2345          *  clear the ACK bit.
2346          *
2347          *  \param epNumber Contains the data endpoint number.
2348          *            Valid values are between 1 and 8.
2349          *
2350          *  \return
2351          *  If an ACKed transaction occurred, this function returns a non-zero value.
2352          *  Otherwise, it returns zero.
2353          *
2354          *******************************************************************************/
2355          uint8 USB_GetEPAckState(uint8 epNumber) CYREENTRANT
2356          {
2357   1          uint8 cr = 0u;
2358   1      
2359   1          if ((epNumber > USB_EP0) && (epNumber < USB_MAX_EP))
2360   1          {
2361   2              cr = USB_SIE_EP_BASE.sieEp[epNumber].epCr0 & USB_MODE_ACKD;
2362   2          }
2363   1      
2364   1          return ((uint8) cr);
2365   1      }
2366          
2367          
2368          /*******************************************************************************
2369          * Function Name: USB_SetPowerStatus
2370          ****************************************************************************//**
2371          *
2372          *  This function sets the current power status. The device replies to USB
2373          *  GET_STATUS requests based on this value. This allows the device to properly
2374          *  report its status for USB Chapter 9 compliance. Devices can change their
2375          *  power source from self powered to bus powered at any time and report their
2376          *  current power source as part of the device status. You should call this
2377          *  function any time your device changes from self powered to bus powered or
2378          *  vice versa, and set the status appropriately.
2379          *
2380          *  \param powerStatus: Contains the desired power status, one for self powered
2381          *        or zero for bus powered. Symbolic names and their associated values are
2382          *        given here:
2383          *  Power Status                                |Description
2384          *  --------------------------------------------|---------------------------
2385          *  USB_DEVICE_STATUS_BUS_POWERED  | Set the device to bus powered
2386          *  USB_DEVICE_STATUS_SELF_POWERED | Set the device to self powered
2387          *
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 41  

2388          * \globalvars
2389          *
2390          *  \ref USB_deviceStatus - set power status
2391          *
2392          * \reentrant
2393          *  No.
2394          *
2395          *******************************************************************************/
2396          void USB_SetPowerStatus(uint8 powerStatus) 
2397          {
2398   1          if (powerStatus != USB_DEVICE_STATUS_BUS_POWERED)
2399   1          {
2400   2              USB_deviceStatus |= (uint8)  USB_DEVICE_STATUS_SELF_POWERED;
2401   2          }
2402   1          else
2403   1          {
2404   2              USB_deviceStatus &= (uint8) ~USB_DEVICE_STATUS_SELF_POWERED;
2405   2          }
2406   1      }
2407          
2408          
2409          #if (USB_VBUS_MONITORING_ENABLE)
                  /***************************************************************************
                  * Function Name: USB_VBusPresent
                  ************************************************************************//**
                  *
                  *  Determines VBUS presence for self-powered devices. This function is
                  *  available when the VBUS Monitoring option is enabled in the Advanced tab.
                  *
                  * \return
                  *  The return value can be the following:
                  *  Return Value | Description
                  *  -------------|-----------------
                  *  1            | VBUS is present
                  *  0            | VBUS is absent
                  *
                  *
                  ***************************************************************************/
                  uint8 USB_VBusPresent(void) 
                  {
                      return ((0u != (USB_VBUS_STATUS_REG & USB_VBUS_VALID)) ? (uint8) 1u : (uint8) 0u);
                  }
              #endif /* (USB_VBUS_MONITORING_ENABLE) */
2431          
2432          
2433          /*******************************************************************************
2434          * Function Name: USB_RWUEnabled
2435          ****************************************************************************//**
2436          *
2437          *  This function returns the current remote wakeup status.
2438          *  If the device supports remote wakeup, the application should use this
2439          *  function to determine if remote wakeup was enabled by the host. When the
2440          *  device is suspended and it determines the conditions to initiate a remote
2441          *  wakeup are met, the application should use the USBFS_Force() function to
2442          *  force the appropriate J and K states onto the USB bus, signaling a remote
2443          *  wakeup.
2444          *
2445          *
2446          * \return
2447          *  Returns non-zero value if remote wakeup is enabled and zero otherwise.
2448          *
2449          * \globalvars
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 42  

2450          *  USB_deviceStatus - checked to determine remote status
2451          *
2452          *******************************************************************************/
2453          uint8 USB_RWUEnabled(void) 
2454          {
2455   1          uint8 result = USB_FALSE;
2456   1      
2457   1          if (0u != (USB_deviceStatus & USB_DEVICE_STATUS_REMOTE_WAKEUP))
2458   1          {
2459   2              result = USB_TRUE;
2460   2          }
2461   1      
2462   1          return (result);
2463   1      }
2464          
2465          
2466          /*******************************************************************************
2467          * Function Name: USB_GetDeviceAddress
2468          ****************************************************************************//**
2469          *
2470          *  This function returns the currently assigned address for the USB device.
2471          *
2472          * \return
2473          *  Returns the currently assigned address.
2474          *  Returns 0 if the device has not yet been assigned an address.
2475          *
2476          *******************************************************************************/
2477          uint8 USB_GetDeviceAddress(void) 
2478          {
2479   1          return (uint8)(USB_CR0_REG & USB_CR0_DEVICE_ADDRESS_MASK);
2480   1      }
2481          
2482          
2483          /*******************************************************************************
2484          * Function Name: USB_EnableSofInt
2485          ****************************************************************************//**
2486          *
2487          *  This function enables interrupt generation when a Start-of-Frame (SOF)
2488          *  packet is received from the host.
2489          *
2490          *******************************************************************************/
2491          void USB_EnableSofInt(void) 
2492          {
2493   1      #if (CY_PSOC4)
                  /* Enable SOF interrupt interrupt source. */
                  USB_INTR_SIE_MASK_REG |= (uint32) USB_INTR_SIE_SOF_INTR;
              #else
2497   1          /* Enable SOF interrupt if it is present. */
2498   1          #if (USB_SOF_ISR_ACTIVE)
2499   1              CyIntEnable(USB_SOF_VECT_NUM);
2500   1          #endif /* (USB_SOF_ISR_ACTIVE) */
2501   1      #endif /* (CY_PSOC4) */
2502   1      }
2503          
2504          
2505          /*******************************************************************************
2506          * Function Name: USB_DisableSofInt
2507          ****************************************************************************//**
2508          *
2509          *  This function disables interrupt generation when a Start-of-Frame (SOF)
2510          *  packet is received from the host.
2511          *
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 43  

2512          *******************************************************************************/
2513          void USB_DisableSofInt(void) 
2514          {
2515   1      #if (CY_PSOC4)
                  /* Disable SOF interrupt interrupt source. */
                  USB_INTR_SIE_MASK_REG &= (uint32) ~USB_INTR_SIE_SOF_INTR;
              #else
2519   1          /* Disable SOF interrupt if it is present. */
2520   1          #if (USB_SOF_ISR_ACTIVE)
2521   1              CyIntDisable(USB_SOF_VECT_NUM);
2522   1          #endif /* (USB_SOF_ISR_ACTIVE) */
2523   1      #endif /* (CY_PSOC4) */
2524   1      }
2525          
2526          
2527          #if (USB_BATT_CHARG_DET_ENABLE)
                  /***************************************************************************
                  * Function Name: USB_DetectPortType
                  ************************************************************************//**
                  *
                  *   This function implements the USB  Battery Charger Detection (BCD)
                  *   algorithm to determine the type of USB host downstream port. This API
                  *   is available only for PSoC 4 devices, and should be called when the VBUS
                  *   voltage transition (OFF to ON) is detected on the bus. If the USB device
                  *   functionality is enabled, this API first calls USBFS_Stop() API
                  *   internally to disable the USB device functionality, and then proceeds to
                  *   implement the BCD algorithm to detect the USB host port type.
                  *   The USBFS_Start() API should be called after this API if the USB
                  *   communication needs to be initiated with the host.
                  *   *Note* This API is generated only if the “Enable Battery Charging 
                  *   Detection” option is enabled in the “Advanced” tab of the component GUI.
                  *   *Note* API implements the steps 2-4 of the BCD algorithm which are 
                  *   - Data Contact Detect
                  *   - Primary Detection 
                  *   - Secondary Detection 
                  * 
                  *   The first step of BCD algorithm, namely, VBUS detection shall be handled 
                  *   at the application firmware level.
                  *
                  * \return
                  *   The return value can be the following:
                  *   Return Value                      |Description
                  *   ----------------------------------|-------------------------------------
                  *   USB_BCD_PORT_SDP     | Standard downstream port detected
                  *   USB_BCD_PORT_CDP     | Charging downstream port detected
                  *   USB_BCD_PORT_DCP     | Dedicated charging port detected
                  *   USB_BCD_PORT_UNKNOWN | Unable to detect charging port type (proprietary charger type)
                  *   USB_BCD_PORT_ERR     | Error condition in detection process
                  *
                  *
                  * \sideeffects
                  *
                  *  USB device functionality is disabled by this API if not already disabled.
                  *
                  ***************************************************************************/
                  uint8 USB_Bcd_DetectPortType(void)
                  {
                      uint32 bkPwrCtrl;
                      uint32 cr1RegVal;
                      uint32 secondaryDetection = 0u;
                      uint8 result = USB_BCD_PORT_UNKNOWN;
              
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 44  

                      /*Check USB Started and Stop it*/
                      if(0u != USB_initVar)
                      {
                          USB_Stop();
                      }
                      /*Initialize USBFS IP for Charger detection*/
              
                      /*Enable clock to USB IP. */
                      USB_USB_CLK_EN_REG = USB_USB_CLK_CSR_CLK_EN;
              
                      /* Enable USBIO control on drive mode of D+ and D- pins. */
                      USB_USBIO_CR1_REG &= ~ (uint32) USB_USBIO_CR1_IOMODE;
              
                      /* Select VBUS detection source and clear PHY isolate. The application
                      *  level must ensure that VBUS is valid. There is no need to wait 2us
                      *  before VBUS is valid.
                      */
                      bkPwrCtrl = USB_POWER_CTRL_REG;
                      USB_POWER_CTRL_REG = USB_DEFAULT_POWER_CTRL_VBUS\
                                          & (~USB_POWER_CTRL_ENABLE_VBUS_PULLDOWN)\
                                          & (~USB_POWER_CTRL_ENABLE_DM_PULLDOWN);
              
              
                      /* Enable PHY detector and single-ended and differential receivers.
                       * Enable charger detection.  */
                      USB_POWER_CTRL_REG |= USB_DEFAULT_POWER_CTRL_PHY\
                                                       | USB_POWER_CTRL_ENABLE_CHGDET;
              
                      /* Suspend clear sequence. */
                      USB_POWER_CTRL_REG &= (uint32) ~USB_POWER_CTRL_SUSPEND;
                      CyDelayUs(USB_WAIT_SUSPEND_DEL_DISABLE);
                      USB_POWER_CTRL_REG &= (uint32) ~USB_POWER_CTRL_SUSPEND_DEL;
              
                      /* Data connection detection
                      * Realization with delay as Hard IP does not support DCD 300 ms.
                      */
                      #if defined (USB_NO_DCD)
                      CyDelay(USB_BCD_TIMEOUT);
                      #else
                      /* DCD implementation:*/
              
                      {
                          uint16 timeout = USB_BCD_TIMEOUT;
                          uint8 connectionApproved = 0u;
                          uint8 connected = 0u;
              
                          /*   BCD spec 1.2: Turns on Idp_src and D- pull-down resistor */
                          USB_POWER_CTRL_REG |= USB_POWER_CTRL_ENABLE_DM_PULLDOWN;
                          USB_CHGDET_CTRL_REG |= USB_CHGDET_CTRL_DCD_SRC_EN;
              
                          /* BCD spec 1.2: Waits for D+ to be low for a time of Tdcd_dbnc*/
                          while ((0u != timeout) && (0u == connectionApproved))
                          {
                              if (0u == (USB_USBIO_CR1_REG & USB_USBIO_CR1_DP0))
                              {
                                  connected++;
                              }
                              else
                              {
                                  connected = 0u;
                              }
                              connectionApproved = (USB_BCD_TDCD_DBNC < connected) ? 1u:0u;
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 45  

                              CyDelay(1u);
                              timeout--;
                          }
              
                          /*   BCD spec 1.2: Turns off Idp_src. */
                          USB_CHGDET_CTRL_REG &= ~USB_CHGDET_CTRL_DCD_SRC_EN;
                      }
                      #endif /*(USB_NO_DCD)*/
              
                      /* Primary detection: enable VDP_SRC on D+ and IDM_SINK on D-. */
                      USB_CHGDET_CTRL_REG = USB_CHGDET_CTRL_PRIMARY;
                      CyDelay(USB_BCD_PRIMARY_WAIT);
                      cr1RegVal = USB_USBIO_CR1_REG;
              
                      /* Check is it SDP or DCP/CDP, read comparator 2 output. */
                      if (0u == (USB_CHGDET_CTRL_REG & USB_CHGDET_CTRL_COMP_OUT))
                      {
                          /* Check status of D- line. */
                          if (0u == (cr1RegVal & USB_USBIO_CR1_DM0))
                          {
                              result = USB_BCD_PORT_SDP;
                          }
                          else
                          {
                              /* ERROR: such combination is impossible. Abort charger
                               * detection.
                              */
                              result = USB_BCD_PORT_ERR;
                          }
                      }
                      else
                      {
                              /* Need Secondary detection. Charging port: DCP or proprietary*/
                              secondaryDetection = 1u;
                      }
              
                      /* Secondary detection: Set CHGDET_CTRL register to enable VDM_SRC on D- and IDP_SINK on D+. */
              
                      if (0u != secondaryDetection)
                      {
                          USB_CHGDET_CTRL_REG = USB_CHGDET_CTRL_DEFAULT \
                                                              | USB_CHGDET_CTRL_SECONDARY;
                          CyDelay(USB_BCD_SECONDARY_WAIT);
                          cr1RegVal = USB_USBIO_CR1_REG;
              
                          /* Check is it SDP or DCP/CDP, read comparator 1 output. */
                          if (0u == (USB_CHGDET_CTRL_REG & USB_CHGDET_CTRL_COMP_OUT))
                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USB_USBIO_CR1_DP0))
                              {
                                  result = USB_BCD_PORT_CDP;
                              }
                              else
                              {
                                  /* ERROR: such combination is impossible. Abort charger
                                   * detection.
                                  */
                                  result = USB_BCD_PORT_ERR;
                              }
                          }
                          else
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 46  

                          {
                              /* Check status of D+ line. */
                              if (0u == (cr1RegVal & USB_USBIO_CR1_DP0))
                              {
                                  result = USB_BCD_PORT_DCP;
                              }
                              else
                              {
                                  /* It is may be proprietary charger. Proprietary charge is
                                   * not supported byHardware IP block.
                                  */
                                  result = USB_BCD_PORT_UNKNOWN;
                              }
                          }
                      }
              
                      /* Restore CHGDET_CTRL. */
                      USB_CHGDET_CTRL_REG = 0u;
              
                      /*Revert registers back*/
                      USB_POWER_CTRL_REG = bkPwrCtrl;
                      USB_USBIO_CR1_REG |= (uint32) USB_USBIO_CR1_IOMODE;
                      USB_USB_CLK_EN_REG = ~USB_USB_CLK_CSR_CLK_EN;
              
                      return (result);
                  }
              #endif  /* (USB_BATT_CHARG_DET_ENABLE) */
2725          
2726          
2727          #if (USB_LPM_ACTIVE)
                  /***************************************************************************
                  * Function Name: USB_Lpm_GetBeslValue
                  ************************************************************************//**
                  *
                  *  This function returns the Best Effort Service Latency (BESL) value
                  *  sent by the host as part of the LPM token transaction.
                  *
                  * \return
                  *  4-bit BESL value received in the LPM token packet from the host
                  *
                  *
                  ***************************************************************************/
                  uint32 USB_Lpm_GetBeslValue(void)
                  {
                      return (uint32) (USB_LPM_STAT_REG & USB_LPM_STAT_LPM_BESL_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USB_Lpm_RemoteWakeUpAllowed
                  ************************************************************************//**
                  *
                  *  This function returns the remote wakeup permission set for the device by
                  *  the host as part of the LPM token transaction.
                  *
                  * \return
                  *   0 - remote wakeup not allowed, 1 - remote wakeup allowed
                  *
                  *
                  ***************************************************************************/
                  uint32 USB_Lpm_RemoteWakeUpAllowed(void)
                  {
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 47  

                      return (uint32) (USB_LPM_STAT_REG & USB_LPM_STAT_LPM_REMOTE_WAKE);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USB_Lpm_SetResponse
                  ************************************************************************//**
                  *
                  *  This function configures the response in the handshake packet the device
                  *  has to send when an LPM token packet is received.
                  *
                  * \param response
                  *   type of response to return for an LPM token packet
                  *   Allowed response values:
                  *       - USB_LPM_REQ_ACK - next LPM request will be
                  *                                           responded with ACK
                  *       - USB_LPM_REQ_NACK - next LPM request will be
                  *                                           responded with NACK
                  *       - USB_LPM_REQ_NYET - next LPM request will be
                  *                                           responded with NYET
                  *
                  ***************************************************************************/
                  void USB_Lpm_SetResponse(uint32 response)
                  {
                      uint32 lpmCtrl = USB_LPM_CTRL_REG & (uint32) ~USB_LPM_CTRL_ACK_NYET_MASK;
              
                      USB_LPM_CTRL_REG = lpmCtrl | ((uint32) response & USB_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
                  /***************************************************************************
                  * Function Name: USB_Lpm_GetResponse
                  ************************************************************************//**
                  *
                  *  This function returns the currently configured response value that the
                  *  device will send as part of the handshake packet when an LPM token
                  *  packet is received.
                  *
                  * \return
                  *   type of handshake response that will be returned by the device
                  *   for an LPM token packet
                  *   Possible response values:
                  *       - USB_LPM_REQ_ACK - next LPM request will be responded
                  *                                        with ACK
                  *       - USB_LPM_REQ_NACK - next LPM request will be responded
                  *                                        with NACK
                  *       - USB_LPM_REQ_NYET - next LPM request will be responded
                  *                                        with NYET
                  *
                  ***************************************************************************/
                  uint32 USB_Lpm_GetResponse(void)
                  {
              
                      return  ((uint32) USB_LPM_CTRL_REG & (uint32)USB_LPM_CTRL_ACK_NYET_MASK);
                  }
              
              
              #endif /* (USB_LPM_ACTIVE) */
2818          
2819          
2820          /* [] END OF FILE */
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 48  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _USB_Start (BEGIN)
                                           ; SOURCE LINE # 186
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 187
                                           ; SOURCE LINE # 188
000A 900000      R     MOV     DPTR,#USB_initVar
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 190
0012 120000      R     LCALL   USB_Init
                                           ; SOURCE LINE # 191
0015 900000      R     MOV     DPTR,#USB_initVar
0018 7401              MOV     A,#01H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 192
001B         ?C0001:
                                           ; SOURCE LINE # 194
001B 900000      R     MOV     DPTR,#device
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 900000      R     MOV     DPTR,#mode
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 120000      R     LCALL   _USB_InitComponent
                                           ; SOURCE LINE # 195
0028 22                RET     
             ; FUNCTION _USB_Start (END)

             ; FUNCTION USB_Init (BEGIN)
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 250
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0008 9043A5            MOV     DPTR,#043A5H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 259
0013 9043B5            MOV     DPTR,#043B5H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4401              ORL     A,#01H
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 49  

001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
001E 90609D            MOV     DPTR,#0609DH
0021 7401              MOV     A,#01H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 264
0024 906009            MOV     DPTR,#06009H
0027 7402              MOV     A,#02H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
002A 906010            MOV     DPTR,#06010H
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 547F              ANL     A,#07FH
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 269
0035 7F00              MOV     R7,#00H
0037 7E00              MOV     R6,#00H
0039 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 274
003C 904394            MOV     DPTR,#04394H
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 EF                MOV     A,R7
0042 54F9              ANL     A,#0F9H
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 278
0047 906012            MOV     DPTR,#06012H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 54DF              ANL     A,#0DFH
004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 281
0052 904394            MOV     DPTR,#04394H
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 4401              ORL     A,#01H
005A FF                MOV     R7,A
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 283
005D 7F01              MOV     R7,#01H
005F 7E00              MOV     R6,#00H
0061 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 285
0064 7F28              MOV     R7,#028H
0066 7E00              MOV     R6,#00H
0068 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 287
006B 9051F8            MOV     DPTR,#051F8H
006E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 50  

006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 547F              ANL     A,#07FH
0073 FF                MOV     R7,A
0074 EF                MOV     A,R7
0075 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 288
0076 9051F8            MOV     DPTR,#051F8H
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C 54BF              ANL     A,#0BFH
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
0081 904394            MOV     DPTR,#04394H
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 4402              ORL     A,#02H
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
008C 7F02              MOV     R7,#02H
008E 7E00              MOV     R6,#00H
0090 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 294
0093 904394            MOV     DPTR,#04394H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 4404              ORL     A,#04H
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
009E 906084            MOV     DPTR,#06084H
00A1 E4                CLR     A
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 298
00A3 906085            MOV     DPTR,#06085H
00A6 E4                CLR     A
00A7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
00A8 900000      R     MOV     DPTR,#enableInterrupts
00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 331
00B0 7D07              MOV     R5,#07H
00B2 7F17              MOV     R7,#017H
00B4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 332
00B7 7C00        E     MOV     R4,#HIGH USB_BUS_RESET_ISR
00B9 7D00        E     MOV     R5,#LOW USB_BUS_RESET_ISR
00BB 7F17              MOV     R7,#017H
00BD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 335
00C0 7D07              MOV     R5,#07H
00C2 7F18              MOV     R7,#018H
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 51  

00C4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 336
00C7 7C00        E     MOV     R4,#HIGH USB_EP_0_ISR
00C9 7D00        E     MOV     R5,#LOW USB_EP_0_ISR
00CB 7F18              MOV     R7,#018H
00CD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 340
00D0 7D07              MOV     R5,#07H
00D2 7F15              MOV     R7,#015H
00D4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 341
00D7 7C00        E     MOV     R4,#HIGH USB_SOF_ISR
00D9 7D00        E     MOV     R5,#LOW USB_SOF_ISR
00DB 7F15              MOV     R7,#015H
00DD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 346
00E0 7D07              MOV     R5,#07H
00E2 7F05              MOV     R7,#05H
00E4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 347
00E7 7C00        E     MOV     R4,#HIGH USB_EP_1_ISR
00E9 7D00        E     MOV     R5,#LOW USB_EP_1_ISR
00EB 7F05              MOV     R7,#05H
00ED 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 352
00F0 7D07              MOV     R5,#07H
00F2 7F06              MOV     R7,#06H
00F4 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 353
00F7 7C00        E     MOV     R4,#HIGH USB_EP_2_ISR
00F9 7D00        E     MOV     R5,#LOW USB_EP_2_ISR
00FB 7F06              MOV     R7,#06H
00FD 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 401
0100 7D07              MOV     R5,#07H
0102 7F0C              MOV     R7,#0CH
0104 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 402
0107 7C00        E     MOV     R4,#HIGH USB_DP_ISR
0109 7D00        E     MOV     R5,#LOW USB_DP_ISR
010B 7F0C              MOV     R7,#0CH
010D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 409
0110 22                RET     
             ; FUNCTION USB_Init (END)

             ; FUNCTION _USB_InitComponent (BEGIN)
                                           ; SOURCE LINE # 460
0000 900000      R     MOV     DPTR,#device
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#mode
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 461
                                           ; SOURCE LINE # 476
000A 900000      R     MOV     DPTR,#device
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F 900000      E     MOV     DPTR,#USB_device
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 52  

                                           ; SOURCE LINE # 479
0014 900000      E     MOV     DPTR,#USB_transferState
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 480
0019 900000      E     MOV     DPTR,#USB_configurationChanged
001C E4                CLR     A
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 481
001E 900000      E     MOV     DPTR,#USB_configuration
0021 E4                CLR     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
0023 900000      E     MOV     DPTR,#USB_interfaceNumber
0026 E4                CLR     A
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 483
0028 900000      E     MOV     DPTR,#USB_deviceAddress
002B E4                CLR     A
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 484
002D 900000      E     MOV     DPTR,#USB_deviceStatus
0030 E4                CLR     A
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 485
0032 900000      E     MOV     DPTR,#USB_lastPacketSize
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 493
0037 9044C2            MOV     DPTR,#044C2H
003A 7480              MOV     A,#080H
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 494
003D 9044C3            MOV     DPTR,#044C3H
0040 7401              MOV     A,#01H
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 497
0043 9044C2            MOV     DPTR,#044C2H
0046 7420              MOV     A,#020H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 501
0049 9044C0            MOV     DPTR,#044C0H
004C 7420              MOV     A,#020H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 505
004F 9044C0            MOV     DPTR,#044C0H
0052 7440              MOV     A,#040H
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 573
0055 900000      R     MOV     DPTR,#mode
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A EF                MOV     A,R7
005B 120000      E     LCALL   ?C?CCASE
005E 0000        R     DW      ?C0005
0060 00                DB      00H
0061 0000        R     DW      ?C0006
0063 01                DB      01H
0064 0000              DW      00H
0066 0000        R     DW      ?C0007
                                           ; SOURCE LINE # 574
                                           ; SOURCE LINE # 575
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 53  

0068         ?C0005:
                                           ; SOURCE LINE # 577
0068 906009            MOV     DPTR,#06009H
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
006D EF                MOV     A,R7
006E 54FE              ANL     A,#0FEH
0070 FF                MOV     R7,A
0071 EF                MOV     A,R7
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 578
0073 8018              SJMP    ?C0004
                                           ; SOURCE LINE # 580
0075         ?C0006:
                                           ; SOURCE LINE # 582
0075 906009            MOV     DPTR,#06009H
0078 E0                MOVX    A,@DPTR
0079 FF                MOV     R7,A
007A EF                MOV     A,R7
007B 4401              ORL     A,#01H
007D FF                MOV     R7,A
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 583
0080 800B              SJMP    ?C0004
                                           ; SOURCE LINE # 585
0082         ?C0007:
                                           ; SOURCE LINE # 591
0082 906009            MOV     DPTR,#06009H
0085 E0                MOVX    A,@DPTR
0086 FF                MOV     R7,A
0087 EF                MOV     A,R7
0088 4401              ORL     A,#01H
008A FF                MOV     R7,A
008B EF                MOV     A,R7
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 593
                                           ; SOURCE LINE # 594
008D         ?C0004:
                                           ; SOURCE LINE # 627
008D 906028            MOV     DPTR,#06028H
0090 7403              MOV     A,#03H
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 630
0093 906008            MOV     DPTR,#06008H
0096 7480              MOV     A,#080H
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 631
0099 7F01              MOV     R7,#01H
009B 7E00              MOV     R6,#00H
009D 7D00              MOV     R5,#00H
009F 7C00              MOV     R4,#00H
00A1 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 635
00A4 906012            MOV     DPTR,#06012H
00A7 7404              MOV     A,#04H
00A9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 636
00AA 22                RET     
             ; FUNCTION _USB_InitComponent (END)

             ; FUNCTION USB_ReInitComponent (BEGIN)
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 54  

                                           ; SOURCE LINE # 671
                                           ; SOURCE LINE # 672
                                           ; SOURCE LINE # 686
0000 900000      E     MOV     DPTR,#USB_transferState
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 687
0005 900000      E     MOV     DPTR,#USB_configurationChanged
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 688
000A 900000      E     MOV     DPTR,#USB_configuration
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
000F 900000      E     MOV     DPTR,#USB_interfaceNumber
0012 E4                CLR     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0014 900000      E     MOV     DPTR,#USB_deviceAddress
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 691
0019 900000      E     MOV     DPTR,#USB_deviceStatus
001C E4                CLR     A
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 692
001E 900000      E     MOV     DPTR,#USB_lastPacketSize
0021 E4                CLR     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 699
0023 906028            MOV     DPTR,#06028H
0026 7403              MOV     A,#03H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 703
0029 906008            MOV     DPTR,#06008H
002C 7480              MOV     A,#080H
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 704
002F 22                RET     
             ; FUNCTION USB_ReInitComponent (END)

             ; FUNCTION USB_Stop (BEGIN)
                                           ; SOURCE LINE # 729
                                           ; SOURCE LINE # 730
                                           ; SOURCE LINE # 738
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 741
0008 906008            MOV     DPTR,#06008H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 547F              ANL     A,#07FH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 744
0013 906012            MOV     DPTR,#06012H
0016 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 55  

0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FB              ANL     A,#0FBH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 751
001E 9043A5            MOV     DPTR,#043A5H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 54FE              ANL     A,#0FEH
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 752
0029 9043B5            MOV     DPTR,#043B5H
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 54FE              ANL     A,#0FEH
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 756
0034 9051F8            MOV     DPTR,#051F8H
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 EF                MOV     A,R7
003A 4480              ORL     A,#080H
003C FF                MOV     R7,A
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 757
003F 9051F8            MOV     DPTR,#051F8H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 4440              ORL     A,#040H
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
004A 900000      R     MOV     DPTR,#enableInterrupts
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 770
0052 9044CA            MOV     DPTR,#044CAH
0055 7480              MOV     A,#080H
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 771
0058 9044CB            MOV     DPTR,#044CBH
005B 7401              MOV     A,#01H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 774
005E 9044CA            MOV     DPTR,#044CAH
0061 7420              MOV     A,#020H
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 778
0064 9044C8            MOV     DPTR,#044C8H
0067 7420              MOV     A,#020H
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 56  

0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 782
006A 9044C8            MOV     DPTR,#044C8H
006D 7440              MOV     A,#040H
006F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0070 120000      E     LCALL   USB_Dp_ClearInterrupt
                                           ; SOURCE LINE # 812
0073 9044D9            MOV     DPTR,#044D9H
0076 7410              MOV     A,#010H
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 818
0079 900000      E     MOV     DPTR,#USB_configurationChanged
007C E4                CLR     A
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 819
007E 900000      E     MOV     DPTR,#USB_configuration
0081 E4                CLR     A
0082 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 820
0083 900000      E     MOV     DPTR,#USB_interfaceNumber
0086 E4                CLR     A
0087 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 821
0088 900000      E     MOV     DPTR,#USB_deviceAddress
008B E4                CLR     A
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 822
008D 900000      E     MOV     DPTR,#USB_deviceStatus
0090 E4                CLR     A
0091 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 825
0092 900000      R     MOV     DPTR,#USB_initVar
0095 E4                CLR     A
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 826
0097 22                RET     
             ; FUNCTION USB_Stop (END)

             ; FUNCTION USB_CheckActivity (BEGIN)
                                           ; SOURCE LINE # 849
                                           ; SOURCE LINE # 850
                                           ; SOURCE LINE # 851
0000 906009            MOV     DPTR,#06009H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#cr1Reg
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 854
000A 900000      R     MOV     DPTR,#cr1Reg
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 54FB              ANL     A,#0FBH
0012 FF                MOV     R7,A
0013 906009            MOV     DPTR,#06009H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 857
0018 900000      R     MOV     DPTR,#cr1Reg
001B E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 57  

001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 30E204            JNB     ACC.2,?C0011
0021 7F01              MOV     R7,#01H
0023 8002              SJMP    ?C0012
0025         ?C0011:
0025 7F00              MOV     R7,#00H
0027         ?C0012:
                                           ; SOURCE LINE # 858
0027         ?C0013:
0027 22                RET     
             ; FUNCTION USB_CheckActivity (END)

             ; FUNCTION USB_GetConfiguration (BEGIN)
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 873
                                           ; SOURCE LINE # 874
0000 900000      E     MOV     DPTR,#USB_configuration
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 875
0005         ?C0014:
0005 22                RET     
             ; FUNCTION USB_GetConfiguration (END)

             ; FUNCTION USB_IsConfigurationChanged (BEGIN)
                                           ; SOURCE LINE # 898
                                           ; SOURCE LINE # 899
                                           ; SOURCE LINE # 900
0000 900000      R     MOV     DPTR,#res
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 902
0005 900000      E     MOV     DPTR,#USB_configurationChanged
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0015
                                           ; SOURCE LINE # 903
                                           ; SOURCE LINE # 904
000D 900000      E     MOV     DPTR,#USB_configurationChanged
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 900000      R     MOV     DPTR,#res
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 905
0017 900000      E     MOV     DPTR,#USB_configurationChanged
001A E4                CLR     A
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 906
001C         ?C0015:
                                           ; SOURCE LINE # 908
001C 900000      R     MOV     DPTR,#res
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
                                           ; SOURCE LINE # 909
0021         ?C0016:
0021 22                RET     
             ; FUNCTION USB_IsConfigurationChanged (END)

             ; FUNCTION _USB_GetInterfaceSetting (BEGIN)
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 58  

                                           ; SOURCE LINE # 927
0000 900000      R     MOV     DPTR,#interfaceNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 929
                                           ; SOURCE LINE # 930
0005 900000      R     MOV     DPTR,#interfaceNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 7400        E     MOV     A,#LOW USB_interfaceSetting
000C 2F                ADD     A,R7
000D F582              MOV     DPL,A
000F E4                CLR     A
0010 3400        E     ADDC    A,#HIGH USB_interfaceSetting
0012 F583              MOV     DPH,A
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
                                           ; SOURCE LINE # 931
0016         ?C0017:
0016 22                RET     
             ; FUNCTION _USB_GetInterfaceSetting (END)

             ; FUNCTION _?USB_GetEPState (BEGIN)
                                           ; SOURCE LINE # 959
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 961
0008 850083      E     MOV     DPH,?C_XBP
000B 850082      E     MOV     DPL,?C_XBP+01H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 75F00B            MOV     B,#0BH
0014 A4                MUL     AB
0015 2400        E     ADD     A,#LOW USB_EP+01H
0017 F582              MOV     DPL,A
0019 E4                CLR     A
001A 3400        E     ADDC    A,#HIGH USB_EP+01H
001C F583              MOV     DPH,A
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
                                           ; SOURCE LINE # 962
0020         ?C0018:
0020 900001            MOV     DPTR,#01H
0023 120000      E     LCALL   ?C?ADDXBP
0026 22                RET     
             ; FUNCTION _?USB_GetEPState (END)

             ; FUNCTION _?USB_GetEPCount (BEGIN)
                                           ; SOURCE LINE # 982
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 90FFFE            MOV     DPTR,#0FFFEH
000B 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 984
000E 850083      E     MOV     DPH,?C_XBP
0011 850082      E     MOV     DPL,?C_XBP+01H
0014 E4                CLR     A
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 59  

0015 F0                MOVX    @DPTR,A
0016 A3                INC     DPTR
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 986
0019 850083      E     MOV     DPH,?C_XBP
001C 850082      E     MOV     DPL,?C_XBP+01H
001F A3                INC     DPTR
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 D3                SETB    C
0025 9400              SUBB    A,#00H
0027 5003              JNC     $ + 5H
0029 020000      R     LJMP    ?C0019
002C 850083      E     MOV     DPH,?C_XBP
002F 850082      E     MOV     DPL,?C_XBP+01H
0032 A3                INC     DPTR
0033 A3                INC     DPTR
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 C3                CLR     C
0038 9409              SUBB    A,#09H
003A 5071              JNC     ?C0019
                                           ; SOURCE LINE # 987
                                           ; SOURCE LINE # 989
003C 850083      E     MOV     DPH,?C_XBP
003F 850082      E     MOV     DPL,?C_XBP+01H
0042 A3                INC     DPTR
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 75F010            MOV     B,#010H
0049 EF                MOV     A,R7
004A 905FFC            MOV     DPTR,#05FFCH
004D 120000      E     LCALL   ?C?OFFXADD
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 7E00              MOV     R6,#00H
0054 7E00              MOV     R6,#00H
0056 EF                MOV     A,R7
0057 540F              ANL     A,#0FH
0059 FF                MOV     R7,A
005A 850083      E     MOV     DPH,?C_XBP
005D 850082      E     MOV     DPL,?C_XBP+01H
0060 EE                MOV     A,R6
0061 F0                MOVX    @DPTR,A
0062 A3                INC     DPTR
0063 EF                MOV     A,R7
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 990
0065 850083      E     MOV     DPH,?C_XBP
0068 850082      E     MOV     DPL,?C_XBP+01H
006B A3                INC     DPTR
006C A3                INC     DPTR
006D E0                MOVX    A,@DPTR
006E FF                MOV     R7,A
006F 75F010            MOV     B,#010H
0072 EF                MOV     A,R7
0073 905FFD            MOV     DPTR,#05FFDH
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 60  

0076 120000      E     LCALL   ?C?OFFXADD
0079 E0                MOVX    A,@DPTR
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C FD                MOV     R5,A
007D 7C00              MOV     R4,#00H
007F 850083      E     MOV     DPH,?C_XBP
0082 850082      E     MOV     DPL,?C_XBP+01H
0085 E0                MOVX    A,@DPTR
0086 FE                MOV     R6,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A EF                MOV     A,R7
008B 7F00              MOV     R7,#00H
008D FE                MOV     R6,A
008E EE                MOV     A,R6
008F 4C                ORL     A,R4
0090 FE                MOV     R6,A
0091 EF                MOV     A,R7
0092 4D                ORL     A,R5
0093 FF                MOV     R7,A
0094 850083      E     MOV     DPH,?C_XBP
0097 850082      E     MOV     DPL,?C_XBP+01H
009A EE                MOV     A,R6
009B F0                MOVX    @DPTR,A
009C A3                INC     DPTR
009D EF                MOV     A,R7
009E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 991
009F 850083      E     MOV     DPH,?C_XBP
00A2 850082      E     MOV     DPL,?C_XBP+01H
00A5 74FF              MOV     A,#0FFH
00A7 75F0FE            MOV     B,#0FEH
00AA 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 992
00AD         ?C0019:
                                           ; SOURCE LINE # 994
00AD 850083      E     MOV     DPH,?C_XBP
00B0 850082      E     MOV     DPL,?C_XBP+01H
00B3 E0                MOVX    A,@DPTR
00B4 FE                MOV     R6,A
00B5 A3                INC     DPTR
00B6 E0                MOVX    A,@DPTR
00B7 FF                MOV     R7,A
                                           ; SOURCE LINE # 995
00B8         ?C0020:
00B8 900003            MOV     DPTR,#03H
00BB 120000      E     LCALL   ?C?ADDXBP
00BE 22                RET     
             ; FUNCTION _?USB_GetEPCount (END)

             ; FUNCTION _?USB_LoadInEP (BEGIN)
                                           ; SOURCE LINE # 1342
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?PSTXDATA
0009 90FFFF            MOV     DPTR,#0FFFFH
000C 120000      E     LCALL   ?C?ADDXBP
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
0011 90FFFE            MOV     DPTR,#0FFFEH
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 61  

0014 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 1343
                                           ; SOURCE LINE # 1345
0017 850083      E     MOV     DPH,?C_XBP
001A 850082      E     MOV     DPL,?C_XBP+01H
001D A3                INC     DPTR
001E A3                INC     DPTR
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 D3                SETB    C
0023 9400              SUBB    A,#00H
0025 5003              JNC     $ + 5H
0027 020000      R     LJMP    ?C0027
002A 850083      E     MOV     DPH,?C_XBP
002D 850082      E     MOV     DPL,?C_XBP+01H
0030 A3                INC     DPTR
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 EF                MOV     A,R7
0035 C3                CLR     C
0036 9409              SUBB    A,#09H
0038 4003              JC      $ + 5H
003A 020000      R     LJMP    ?C0027
                                           ; SOURCE LINE # 1346
                                           ; SOURCE LINE # 1349
003D 850083      E     MOV     DPH,?C_XBP
0040 850082      E     MOV     DPL,?C_XBP+01H
0043 A3                INC     DPTR
0044 A3                INC     DPTR
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 EF                MOV     A,R7
0048 75F00B            MOV     B,#0BH
004B A4                MUL     AB
004C 2400        E     ADD     A,#LOW USB_EP+06H
004E F582              MOV     DPL,A
0050 E4                CLR     A
0051 3400        E     ADDC    A,#HIGH USB_EP+06H
0053 F583              MOV     DPH,A
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A C3                CLR     C
005B E4                CLR     A
005C 9F                SUBB    A,R7
005D FF                MOV     R7,A
005E 7402              MOV     A,#02H
0060 9E                SUBB    A,R6
0061 FE                MOV     R6,A
0062 900006            MOV     DPTR,#06H
0065 120000      E     LCALL   ?C?XBPOFF
0068 E0                MOVX    A,@DPTR
0069 FC                MOV     R4,A
006A A3                INC     DPTR
006B E0                MOVX    A,@DPTR
006C FD                MOV     R5,A
006D D3                SETB    C
006E ED                MOV     A,R5
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 62  

006F 9F                SUBB    A,R7
0070 EC                MOV     A,R4
0071 9E                SUBB    A,R6
0072 4030              JC      ?C0022
                                           ; SOURCE LINE # 1350
                                           ; SOURCE LINE # 1351
0074 850083      E     MOV     DPH,?C_XBP
0077 850082      E     MOV     DPL,?C_XBP+01H
007A A3                INC     DPTR
007B A3                INC     DPTR
007C E0                MOVX    A,@DPTR
007D FF                MOV     R7,A
007E EF                MOV     A,R7
007F 75F00B            MOV     B,#0BH
0082 A4                MUL     AB
0083 2400        E     ADD     A,#LOW USB_EP+06H
0085 F582              MOV     DPL,A
0087 E4                CLR     A
0088 3400        E     ADDC    A,#HIGH USB_EP+06H
008A F583              MOV     DPH,A
008C E0                MOVX    A,@DPTR
008D FE                MOV     R6,A
008E A3                INC     DPTR
008F E0                MOVX    A,@DPTR
0090 FF                MOV     R7,A
0091 C3                CLR     C
0092 E4                CLR     A
0093 9F                SUBB    A,R7
0094 FF                MOV     R7,A
0095 7402              MOV     A,#02H
0097 9E                SUBB    A,R6
0098 FE                MOV     R6,A
0099 900006            MOV     DPTR,#06H
009C 120000      E     LCALL   ?C?XBPOFF
009F EE                MOV     A,R6
00A0 F0                MOVX    @DPTR,A
00A1 A3                INC     DPTR
00A2 EF                MOV     A,R7
00A3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1352
00A4         ?C0022:
                                           ; SOURCE LINE # 1356
00A4 900006            MOV     DPTR,#06H
00A7 120000      E     LCALL   ?C?XBPOFF
00AA E0                MOVX    A,@DPTR
00AB FE                MOV     R6,A
00AC A3                INC     DPTR
00AD E0                MOVX    A,@DPTR
00AE FF                MOV     R7,A
00AF EE                MOV     A,R6
00B0 FF                MOV     R7,A
00B1 7E00              MOV     R6,#00H
00B3 850083      E     MOV     DPH,?C_XBP
00B6 850082      E     MOV     DPL,?C_XBP+01H
00B9 A3                INC     DPTR
00BA A3                INC     DPTR
00BB E0                MOVX    A,@DPTR
00BC FE                MOV     R6,A
00BD EE                MOV     A,R6
00BE 75F00B            MOV     B,#0BH
00C1 A4                MUL     AB
00C2 2400        E     ADD     A,#LOW USB_EP+03H
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 63  

00C4 F582              MOV     DPL,A
00C6 E4                CLR     A
00C7 3400        E     ADDC    A,#HIGH USB_EP+03H
00C9 F583              MOV     DPH,A
00CB E0                MOVX    A,@DPTR
00CC FE                MOV     R6,A
00CD EF                MOV     A,R7
00CE 4E                ORL     A,R6
00CF FF                MOV     R7,A
00D0 850083      E     MOV     DPH,?C_XBP
00D3 850082      E     MOV     DPL,?C_XBP+01H
00D6 A3                INC     DPTR
00D7 A3                INC     DPTR
00D8 E0                MOVX    A,@DPTR
00D9 FE                MOV     R6,A
00DA 75F010            MOV     B,#010H
00DD EE                MOV     A,R6
00DE 905FFC            MOV     DPTR,#05FFCH
00E1 120000      E     LCALL   ?C?OFFXADD
00E4 EF                MOV     A,R7
00E5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1357
00E6 900006            MOV     DPTR,#06H
00E9 120000      E     LCALL   ?C?XBPOFF
00EC E0                MOVX    A,@DPTR
00ED FE                MOV     R6,A
00EE A3                INC     DPTR
00EF E0                MOVX    A,@DPTR
00F0 FF                MOV     R7,A
00F1 EF                MOV     A,R7
00F2 54FF              ANL     A,#0FFH
00F4 FF                MOV     R7,A
00F5 850083      E     MOV     DPH,?C_XBP
00F8 850082      E     MOV     DPL,?C_XBP+01H
00FB A3                INC     DPTR
00FC A3                INC     DPTR
00FD E0                MOVX    A,@DPTR
00FE FE                MOV     R6,A
00FF 75F010            MOV     B,#010H
0102 EE                MOV     A,R6
0103 905FFD            MOV     DPTR,#05FFDH
0106 120000      E     LCALL   ?C?OFFXADD
0109 EF                MOV     A,R7
010A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
010B 7B00              MOV     R3,#00H
010D 7A00              MOV     R2,#00H
010F 7900              MOV     R1,#00H
0111 C003              PUSH    AR3
0113 C002              PUSH    AR2
0115 C001              PUSH    AR1
0117 900003            MOV     DPTR,#03H
011A 120000      E     LCALL   ?C?XBPOFF
011D 120000      E     LCALL   ?C?PLDXDATA
0120 D082              POP     DPL
0122 D083              POP     DPH
0124 D0E0              POP     ACC
0126 6B                XRL     A,R3
0127 7008              JNZ     ?C0051
0129 E9                MOV     A,R1
012A 6582              XRL     A,DPL
012C 7003              JNZ     ?C0051
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 64  

012E EA                MOV     A,R2
012F 6583              XRL     A,DPH
0131         ?C0051:
0131 606B              JZ      ?C0023
                                           ; SOURCE LINE # 1361
                                           ; SOURCE LINE # 1364
0133 850083      E     MOV     DPH,?C_XBP
0136 850082      E     MOV     DPL,?C_XBP+01H
0139 E4                CLR     A
013A F0                MOVX    @DPTR,A
013B A3                INC     DPTR
013C E4                CLR     A
013D F0                MOVX    @DPTR,A
013E         ?C0024:
013E 900006            MOV     DPTR,#06H
0141 120000      E     LCALL   ?C?XBPOFF
0144 E0                MOVX    A,@DPTR
0145 FE                MOV     R6,A
0146 A3                INC     DPTR
0147 E0                MOVX    A,@DPTR
0148 FF                MOV     R7,A
0149 850083      E     MOV     DPH,?C_XBP
014C 850082      E     MOV     DPL,?C_XBP+01H
014F E0                MOVX    A,@DPTR
0150 FC                MOV     R4,A
0151 A3                INC     DPTR
0152 E0                MOVX    A,@DPTR
0153 FD                MOV     R5,A
0154 C3                CLR     C
0155 ED                MOV     A,R5
0156 9F                SUBB    A,R7
0157 EC                MOV     A,R4
0158 9E                SUBB    A,R6
0159 5043              JNC     ?C0023
                                           ; SOURCE LINE # 1365
                                           ; SOURCE LINE # 1366
015B 900003            MOV     DPTR,#03H
015E 120000      E     LCALL   ?C?XBPOFF
0161 120000      E     LCALL   ?C?PLDXDATA
0164 850083      E     MOV     DPH,?C_XBP
0167 850082      E     MOV     DPL,?C_XBP+01H
016A E0                MOVX    A,@DPTR
016B FE                MOV     R6,A
016C A3                INC     DPTR
016D E0                MOVX    A,@DPTR
016E FF                MOV     R7,A
016F E9                MOV     A,R1
0170 2F                ADD     A,R7
0171 F9                MOV     R1,A
0172 EA                MOV     A,R2
0173 3E                ADDC    A,R6
0174 FA                MOV     R2,A
0175 120000      E     LCALL   ?C?CLDPTR
0178 FF                MOV     R7,A
0179 850083      E     MOV     DPH,?C_XBP
017C 850082      E     MOV     DPL,?C_XBP+01H
017F A3                INC     DPTR
0180 A3                INC     DPTR
0181 E0                MOVX    A,@DPTR
0182 FE                MOV     R6,A
0183 75F010            MOV     B,#010H
0186 EE                MOV     A,R6
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 65  

0187 906078            MOV     DPTR,#06078H
018A 120000      E     LCALL   ?C?OFFXADD
018D EF                MOV     A,R7
018E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1367
018F 850083      E     MOV     DPH,?C_XBP
0192 850082      E     MOV     DPL,?C_XBP+01H
0195 E4                CLR     A
0196 75F001            MOV     B,#01H
0199 120000      E     LCALL   ?C?IILDX
019C 80A0              SJMP    ?C0024
                                           ; SOURCE LINE # 1368
019E         ?C0023:
                                           ; SOURCE LINE # 1371
019E 850083      E     MOV     DPH,?C_XBP
01A1 850082      E     MOV     DPL,?C_XBP+01H
01A4 A3                INC     DPTR
01A5 A3                INC     DPTR
01A6 E0                MOVX    A,@DPTR
01A7 FF                MOV     R7,A
01A8 EF                MOV     A,R7
01A9 75F00B            MOV     B,#0BH
01AC A4                MUL     AB
01AD 2400        E     ADD     A,#LOW USB_EP+01H
01AF F582              MOV     DPL,A
01B1 E4                CLR     A
01B2 3400        E     ADDC    A,#HIGH USB_EP+01H
01B4 F583              MOV     DPH,A
01B6 E4                CLR     A
01B7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1374
01B8 850083      E     MOV     DPH,?C_XBP
01BB 850082      E     MOV     DPL,?C_XBP+01H
01BE A3                INC     DPTR
01BF A3                INC     DPTR
01C0 E0                MOVX    A,@DPTR
01C1 FF                MOV     R7,A
01C2 EF                MOV     A,R7
01C3 75F00B            MOV     B,#0BH
01C6 A4                MUL     AB
01C7 2400        E     ADD     A,#LOW USB_EP+05H
01C9 F582              MOV     DPL,A
01CB E4                CLR     A
01CC 3400        E     ADDC    A,#HIGH USB_EP+05H
01CE F583              MOV     DPH,A
01D0 E0                MOVX    A,@DPTR
01D1 FF                MOV     R7,A
01D2 850083      E     MOV     DPH,?C_XBP
01D5 850082      E     MOV     DPL,?C_XBP+01H
01D8 A3                INC     DPTR
01D9 A3                INC     DPTR
01DA E0                MOVX    A,@DPTR
01DB FE                MOV     R6,A
01DC 75F010            MOV     B,#010H
01DF EE                MOV     A,R6
01E0 905FFE            MOV     DPTR,#05FFEH
01E3 120000      E     LCALL   ?C?OFFXADD
01E6 EF                MOV     A,R7
01E7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1603
                                           ; SOURCE LINE # 1604
01E8         ?C0027:
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 66  

01E8 900008            MOV     DPTR,#08H
01EB 120000      E     LCALL   ?C?ADDXBP
01EE 22                RET     
             ; FUNCTION _?USB_LoadInEP (END)

             ; FUNCTION _?USB_ReadOutEP (BEGIN)
                                           ; SOURCE LINE # 1653
0000 90FFFD            MOV     DPTR,#0FFFDH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?PSTXDATA
0009 90FFFF            MOV     DPTR,#0FFFFH
000C 120000      E     LCALL   ?C?ADDXBP
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
0011 90FFFE            MOV     DPTR,#0FFFEH
0014 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 1654
                                           ; SOURCE LINE # 1656
0017 7B00              MOV     R3,#00H
0019 7A00              MOV     R2,#00H
001B 7900              MOV     R1,#00H
001D C003              PUSH    AR3
001F C002              PUSH    AR2
0021 C001              PUSH    AR1
0023 900003            MOV     DPTR,#03H
0026 120000      E     LCALL   ?C?XBPOFF
0029 120000      E     LCALL   ?C?PLDXDATA
002C D082              POP     DPL
002E D083              POP     DPH
0030 D0E0              POP     ACC
0032 6B                XRL     A,R3
0033 7008              JNZ     ?C0052
0035 E9                MOV     A,R1
0036 6582              XRL     A,DPL
0038 7003              JNZ     ?C0052
003A EA                MOV     A,R2
003B 6583              XRL     A,DPH
003D         ?C0052:
003D 7003              JNZ     $ + 5H
003F 020000      R     LJMP    ?C0028
0042 850083      E     MOV     DPH,?C_XBP
0045 850082      E     MOV     DPL,?C_XBP+01H
0048 A3                INC     DPTR
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D D3                SETB    C
004E 9400              SUBB    A,#00H
0050 5003              JNC     $ + 5H
0052 020000      R     LJMP    ?C0028
0055 850083      E     MOV     DPH,?C_XBP
0058 850082      E     MOV     DPL,?C_XBP+01H
005B A3                INC     DPTR
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FF                MOV     R7,A
005F EF                MOV     A,R7
0060 C3                CLR     C
0061 9409              SUBB    A,#09H
0063 4003              JC      $ + 5H
0065 020000      R     LJMP    ?C0028
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 67  

                                           ; SOURCE LINE # 1657
                                           ; SOURCE LINE # 1660
0068 850083      E     MOV     DPH,?C_XBP
006B 850082      E     MOV     DPL,?C_XBP+01H
006E A3                INC     DPTR
006F A3                INC     DPTR
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
0072 120000      R     LCALL   _?USB_GetEPCount
0075 900006            MOV     DPTR,#06H
0078 120000      E     LCALL   ?C?XBPOFF
007B E0                MOVX    A,@DPTR
007C FC                MOV     R4,A
007D A3                INC     DPTR
007E E0                MOVX    A,@DPTR
007F FD                MOV     R5,A
0080 D3                SETB    C
0081 ED                MOV     A,R5
0082 9F                SUBB    A,R7
0083 EC                MOV     A,R4
0084 9E                SUBB    A,R6
0085 400F              JC      ?C0029
0087 850083      E     MOV     DPH,?C_XBP
008A 850082      E     MOV     DPL,?C_XBP+01H
008D A3                INC     DPTR
008E A3                INC     DPTR
008F E0                MOVX    A,@DPTR
0090 FF                MOV     R7,A
0091 120000      R     LCALL   _?USB_GetEPCount
0094 800B              SJMP    ?C0030
0096         ?C0029:
0096 900006            MOV     DPTR,#06H
0099 120000      E     LCALL   ?C?XBPOFF
009C E0                MOVX    A,@DPTR
009D FE                MOV     R6,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 FF                MOV     R7,A
00A1         ?C0030:
00A1 900006            MOV     DPTR,#06H
00A4 120000      E     LCALL   ?C?XBPOFF
00A7 EE                MOV     A,R6
00A8 F0                MOVX    @DPTR,A
00A9 A3                INC     DPTR
00AA EF                MOV     A,R7
00AB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1664
                                           ; SOURCE LINE # 1667
00AC 850083      E     MOV     DPH,?C_XBP
00AF 850082      E     MOV     DPL,?C_XBP+01H
00B2 E4                CLR     A
00B3 F0                MOVX    @DPTR,A
00B4 A3                INC     DPTR
00B5 E4                CLR     A
00B6 F0                MOVX    @DPTR,A
00B7         ?C0031:
00B7 900006            MOV     DPTR,#06H
00BA 120000      E     LCALL   ?C?XBPOFF
00BD E0                MOVX    A,@DPTR
00BE FE                MOV     R6,A
00BF A3                INC     DPTR
00C0 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 68  

00C1 FF                MOV     R7,A
00C2 850083      E     MOV     DPH,?C_XBP
00C5 850082      E     MOV     DPL,?C_XBP+01H
00C8 E0                MOVX    A,@DPTR
00C9 FC                MOV     R4,A
00CA A3                INC     DPTR
00CB E0                MOVX    A,@DPTR
00CC FD                MOV     R5,A
00CD C3                CLR     C
00CE ED                MOV     A,R5
00CF 9F                SUBB    A,R7
00D0 EC                MOV     A,R4
00D1 9E                SUBB    A,R6
00D2 5043              JNC     ?C0032
                                           ; SOURCE LINE # 1668
                                           ; SOURCE LINE # 1669
00D4 850083      E     MOV     DPH,?C_XBP
00D7 850082      E     MOV     DPL,?C_XBP+01H
00DA A3                INC     DPTR
00DB A3                INC     DPTR
00DC E0                MOVX    A,@DPTR
00DD FF                MOV     R7,A
00DE 75F010            MOV     B,#010H
00E1 EF                MOV     A,R7
00E2 906078            MOV     DPTR,#06078H
00E5 120000      E     LCALL   ?C?OFFXADD
00E8 E0                MOVX    A,@DPTR
00E9 FF                MOV     R7,A
00EA 900003            MOV     DPTR,#03H
00ED 120000      E     LCALL   ?C?XBPOFF
00F0 120000      E     LCALL   ?C?PLDXDATA
00F3 850083      E     MOV     DPH,?C_XBP
00F6 850082      E     MOV     DPL,?C_XBP+01H
00F9 E0                MOVX    A,@DPTR
00FA FC                MOV     R4,A
00FB A3                INC     DPTR
00FC E0                MOVX    A,@DPTR
00FD FD                MOV     R5,A
00FE E9                MOV     A,R1
00FF 2D                ADD     A,R5
0100 F9                MOV     R1,A
0101 EA                MOV     A,R2
0102 3C                ADDC    A,R4
0103 FA                MOV     R2,A
0104 EF                MOV     A,R7
0105 120000      E     LCALL   ?C?CSTPTR
                                           ; SOURCE LINE # 1670
0108 850083      E     MOV     DPH,?C_XBP
010B 850082      E     MOV     DPL,?C_XBP+01H
010E E4                CLR     A
010F 75F001            MOV     B,#01H
0112 120000      E     LCALL   ?C?IILDX
0115 80A0              SJMP    ?C0031
0117         ?C0032:
                                           ; SOURCE LINE # 1671
                                           ; SOURCE LINE # 1674
0117 850083      E     MOV     DPH,?C_XBP
011A 850082      E     MOV     DPL,?C_XBP+01H
011D A3                INC     DPTR
011E A3                INC     DPTR
011F E0                MOVX    A,@DPTR
0120 FF                MOV     R7,A
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 69  

0121 120000      R     LCALL   _?USB_EnableOutEP
                                           ; SOURCE LINE # 1817
0124 800B              SJMP    ?C0034
0126         ?C0028:
                                           ; SOURCE LINE # 1819
                                           ; SOURCE LINE # 1820
0126 900006            MOV     DPTR,#06H
0129 120000      E     LCALL   ?C?XBPOFF
012C E4                CLR     A
012D F0                MOVX    @DPTR,A
012E A3                INC     DPTR
012F E4                CLR     A
0130 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1821
0131         ?C0034:
                                           ; SOURCE LINE # 1823
0131 900006            MOV     DPTR,#06H
0134 120000      E     LCALL   ?C?XBPOFF
0137 E0                MOVX    A,@DPTR
0138 FE                MOV     R6,A
0139 A3                INC     DPTR
013A E0                MOVX    A,@DPTR
013B FF                MOV     R7,A
                                           ; SOURCE LINE # 1824
013C         ?C0035:
013C 900008            MOV     DPTR,#08H
013F 120000      E     LCALL   ?C?ADDXBP
0142 22                RET     
             ; FUNCTION _?USB_ReadOutEP (END)

             ; FUNCTION _?USB_EnableOutEP (BEGIN)
                                           ; SOURCE LINE # 2276
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2278
0008 850083      E     MOV     DPH,?C_XBP
000B 850082      E     MOV     DPL,?C_XBP+01H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 D3                SETB    C
0012 9400              SUBB    A,#00H
0014 4052              JC      ?C0037
0016 850083      E     MOV     DPH,?C_XBP
0019 850082      E     MOV     DPL,?C_XBP+01H
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F C3                CLR     C
0020 9409              SUBB    A,#09H
0022 5044              JNC     ?C0037
                                           ; SOURCE LINE # 2279
                                           ; SOURCE LINE # 2280
0024 850083      E     MOV     DPH,?C_XBP
0027 850082      E     MOV     DPL,?C_XBP+01H
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 75F00B            MOV     B,#0BH
0030 A4                MUL     AB
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 70  

0031 2400        E     ADD     A,#LOW USB_EP+01H
0033 F582              MOV     DPL,A
0035 E4                CLR     A
0036 3400        E     ADDC    A,#HIGH USB_EP+01H
0038 F583              MOV     DPH,A
003A E4                CLR     A
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2283
003C 850083      E     MOV     DPH,?C_XBP
003F 850082      E     MOV     DPL,?C_XBP+01H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 75F00B            MOV     B,#0BH
0048 A4                MUL     AB
0049 2400        E     ADD     A,#LOW USB_EP+05H
004B F582              MOV     DPL,A
004D E4                CLR     A
004E 3400        E     ADDC    A,#HIGH USB_EP+05H
0050 F583              MOV     DPH,A
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 850083      E     MOV     DPH,?C_XBP
0057 850082      E     MOV     DPL,?C_XBP+01H
005A E0                MOVX    A,@DPTR
005B FE                MOV     R6,A
005C 75F010            MOV     B,#010H
005F EE                MOV     A,R6
0060 905FFE            MOV     DPTR,#05FFEH
0063 120000      E     LCALL   ?C?OFFXADD
0066 EF                MOV     A,R7
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2285
                                           ; SOURCE LINE # 2286
0068         ?C0037:
0068 900001            MOV     DPTR,#01H
006B 120000      E     LCALL   ?C?ADDXBP
006E 22                RET     
             ; FUNCTION _?USB_EnableOutEP (END)

             ; FUNCTION _USB_DisableOutEP (BEGIN)
                                           ; SOURCE LINE # 2300
0000 900000      R     MOV     DPTR,#epNumber
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2301
                                           ; SOURCE LINE # 2302
0005 900000      R     MOV     DPTR,#epNumber
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B D3                SETB    C
000C 9400              SUBB    A,#00H
000E 401D              JC      ?C0039
0010 900000      R     MOV     DPTR,#epNumber
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 C3                CLR     C
0017 9409              SUBB    A,#09H
0019 5012              JNC     ?C0039
                                           ; SOURCE LINE # 2303
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 71  

                                           ; SOURCE LINE # 2305
001B 900000      R     MOV     DPTR,#epNumber
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 75F010            MOV     B,#010H
0023 EF                MOV     A,R7
0024 905FFE            MOV     DPTR,#05FFEH
0027 120000      E     LCALL   ?C?OFFXADD
002A 7408              MOV     A,#08H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2306
                                           ; SOURCE LINE # 2307
002D         ?C0039:
002D 22                RET     
             ; FUNCTION _USB_DisableOutEP (END)

             ; FUNCTION _USB_Force (BEGIN)
                                           ; SOURCE LINE # 2330
0000 900000      R     MOV     DPTR,#bState
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2331
                                           ; SOURCE LINE # 2335
0005 900000      R     MOV     DPTR,#bState
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906010            MOV     DPTR,#06010H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2336
000F 22                RET     
             ; FUNCTION _USB_Force (END)

             ; FUNCTION _?USB_GetEPAckState (BEGIN)
                                           ; SOURCE LINE # 2355
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
0008 90FFFF            MOV     DPTR,#0FFFFH
000B 120000      E     LCALL   ?C?ADDXBP
                                           ; SOURCE LINE # 2357
000E 850083      E     MOV     DPH,?C_XBP
0011 850082      E     MOV     DPL,?C_XBP+01H
0014 E4                CLR     A
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2359
0016 850083      E     MOV     DPH,?C_XBP
0019 850082      E     MOV     DPL,?C_XBP+01H
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 D3                SETB    C
0021 9400              SUBB    A,#00H
0023 4030              JC      ?C0041
0025 850083      E     MOV     DPH,?C_XBP
0028 850082      E     MOV     DPL,?C_XBP+01H
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 72  

002F C3                CLR     C
0030 9409              SUBB    A,#09H
0032 5021              JNC     ?C0041
                                           ; SOURCE LINE # 2360
                                           ; SOURCE LINE # 2361
0034 850083      E     MOV     DPH,?C_XBP
0037 850082      E     MOV     DPL,?C_XBP+01H
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C FF                MOV     R7,A
003D 75F010            MOV     B,#010H
0040 EF                MOV     A,R7
0041 905FFE            MOV     DPTR,#05FFEH
0044 120000      E     LCALL   ?C?OFFXADD
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
0049 EF                MOV     A,R7
004A 5410              ANL     A,#010H
004C FF                MOV     R7,A
004D 850083      E     MOV     DPH,?C_XBP
0050 850082      E     MOV     DPL,?C_XBP+01H
0053 EF                MOV     A,R7
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2362
0055         ?C0041:
                                           ; SOURCE LINE # 2364
0055 850083      E     MOV     DPH,?C_XBP
0058 850082      E     MOV     DPL,?C_XBP+01H
005B E0                MOVX    A,@DPTR
005C FF                MOV     R7,A
                                           ; SOURCE LINE # 2365
005D         ?C0042:
005D 900002            MOV     DPTR,#02H
0060 120000      E     LCALL   ?C?ADDXBP
0063 22                RET     
             ; FUNCTION _?USB_GetEPAckState (END)

             ; FUNCTION _USB_SetPowerStatus (BEGIN)
                                           ; SOURCE LINE # 2396
0000 900000      R     MOV     DPTR,#powerStatus
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2397
                                           ; SOURCE LINE # 2398
0005 900000      R     MOV     DPTR,#powerStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600F              JZ      ?C0043
                                           ; SOURCE LINE # 2399
                                           ; SOURCE LINE # 2400
000D 900000      E     MOV     DPTR,#USB_deviceStatus
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4401              ORL     A,#01H
0015 FF                MOV     R7,A
0016 900000      E     MOV     DPTR,#USB_deviceStatus
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2401
001B 22                RET     
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 73  

001C         ?C0043:
                                           ; SOURCE LINE # 2403
                                           ; SOURCE LINE # 2404
001C 900000      E     MOV     DPTR,#USB_deviceStatus
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 54FE              ANL     A,#0FEH
0024 FF                MOV     R7,A
0025 900000      E     MOV     DPTR,#USB_deviceStatus
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2405
                                           ; SOURCE LINE # 2406
002A         ?C0045:
002A 22                RET     
             ; FUNCTION _USB_SetPowerStatus (END)

             ; FUNCTION USB_RWUEnabled (BEGIN)
                                           ; SOURCE LINE # 2453
                                           ; SOURCE LINE # 2454
                                           ; SOURCE LINE # 2455
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2457
0005 900000      E     MOV     DPTR,#USB_deviceStatus
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 5402              ANL     A,#02H
000D FF                MOV     R7,A
000E 7E00              MOV     R6,#00H
0010 EF                MOV     A,R7
0011 4E                ORL     A,R6
0012 6006              JZ      ?C0046
                                           ; SOURCE LINE # 2458
                                           ; SOURCE LINE # 2459
0014 900000      R     MOV     DPTR,#result
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2460
001A         ?C0046:
                                           ; SOURCE LINE # 2462
001A 900000      R     MOV     DPTR,#result
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
                                           ; SOURCE LINE # 2463
001F         ?C0047:
001F 22                RET     
             ; FUNCTION USB_RWUEnabled (END)

             ; FUNCTION USB_GetDeviceAddress (BEGIN)
                                           ; SOURCE LINE # 2477
                                           ; SOURCE LINE # 2478
                                           ; SOURCE LINE # 2479
0000 906008            MOV     DPTR,#06008H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
C51 COMPILER V9.51   USB                                                                   07/22/2017 09:26:18 PAGE 74  

                                           ; SOURCE LINE # 2480
0009         ?C0048:
0009 22                RET     
             ; FUNCTION USB_GetDeviceAddress (END)

             ; FUNCTION USB_EnableSofInt (BEGIN)
                                           ; SOURCE LINE # 2491
                                           ; SOURCE LINE # 2492
                                           ; SOURCE LINE # 2499
0000 9044C2            MOV     DPTR,#044C2H
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2502
0006 22                RET     
             ; FUNCTION USB_EnableSofInt (END)

             ; FUNCTION USB_DisableSofInt (BEGIN)
                                           ; SOURCE LINE # 2513
                                           ; SOURCE LINE # 2514
                                           ; SOURCE LINE # 2521
0000 9044CA            MOV     DPTR,#044CAH
0003 7420              MOV     A,#020H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2524
0006 22                RET     
             ; FUNCTION USB_DisableSofInt (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2208    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
